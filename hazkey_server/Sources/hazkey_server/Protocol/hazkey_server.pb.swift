// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: hazkey_server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Hazkey_Commands_QueryData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var function: Hazkey_Commands_QueryData.KkcApi = .setConfig

  var props: Hazkey_Commands_QueryData.OneOf_Props? = nil

  var setConfig: Hazkey_Commands_QueryData.SetConfigProps {
    get {
      if case .setConfig(let v)? = props {return v}
      return Hazkey_Commands_QueryData.SetConfigProps()
    }
    set {props = .setConfig(newValue)}
  }

  var setLeftContext: Hazkey_Commands_QueryData.SetLeftContextProps {
    get {
      if case .setLeftContext(let v)? = props {return v}
      return Hazkey_Commands_QueryData.SetLeftContextProps()
    }
    set {props = .setLeftContext(newValue)}
  }

  var inputText: Hazkey_Commands_QueryData.InputTextProps {
    get {
      if case .inputText(let v)? = props {return v}
      return Hazkey_Commands_QueryData.InputTextProps()
    }
    set {props = .inputText(newValue)}
  }

  var moveCursor: Hazkey_Commands_QueryData.MoveCursorProps {
    get {
      if case .moveCursor(let v)? = props {return v}
      return Hazkey_Commands_QueryData.MoveCursorProps()
    }
    set {props = .moveCursor(newValue)}
  }

  var completePrefix: Hazkey_Commands_QueryData.PrefixCompleteProps {
    get {
      if case .completePrefix(let v)? = props {return v}
      return Hazkey_Commands_QueryData.PrefixCompleteProps()
    }
    set {props = .completePrefix(newValue)}
  }

  var getComposingString: Hazkey_Commands_QueryData.GetComposingStringProps {
    get {
      if case .getComposingString(let v)? = props {return v}
      return Hazkey_Commands_QueryData.GetComposingStringProps()
    }
    set {props = .getComposingString(newValue)}
  }

  var getCandidates: Hazkey_Commands_QueryData.GetCandidatesProps {
    get {
      if case .getCandidates(let v)? = props {return v}
      return Hazkey_Commands_QueryData.GetCandidatesProps()
    }
    set {props = .getCandidates(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Props: Equatable, Sendable {
    case setConfig(Hazkey_Commands_QueryData.SetConfigProps)
    case setLeftContext(Hazkey_Commands_QueryData.SetLeftContextProps)
    case inputText(Hazkey_Commands_QueryData.InputTextProps)
    case moveCursor(Hazkey_Commands_QueryData.MoveCursorProps)
    case completePrefix(Hazkey_Commands_QueryData.PrefixCompleteProps)
    case getComposingString(Hazkey_Commands_QueryData.GetComposingStringProps)
    case getCandidates(Hazkey_Commands_QueryData.GetCandidatesProps)

  }

  enum KkcApi: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case setConfig // = 0
    case setLeftContext // = 1
    case createComposingTextInstance // = 2
    case inputText // = 3
    case deleteLeft // = 4
    case deleteRight // = 5
    case completePrefix // = 6
    case moveCursor // = 7
    case getHiraganaWithCursor // = 8
    case getComposingString // = 9
    case getCandidates // = 10
    case UNRECOGNIZED(Int)

    init() {
      self = .setConfig
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .setConfig
      case 1: self = .setLeftContext
      case 2: self = .createComposingTextInstance
      case 3: self = .inputText
      case 4: self = .deleteLeft
      case 5: self = .deleteRight
      case 6: self = .completePrefix
      case 7: self = .moveCursor
      case 8: self = .getHiraganaWithCursor
      case 9: self = .getComposingString
      case 10: self = .getCandidates
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .setConfig: return 0
      case .setLeftContext: return 1
      case .createComposingTextInstance: return 2
      case .inputText: return 3
      case .deleteLeft: return 4
      case .deleteRight: return 5
      case .completePrefix: return 6
      case .moveCursor: return 7
      case .getHiraganaWithCursor: return 8
      case .getComposingString: return 9
      case .getCandidates: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Hazkey_Commands_QueryData.KkcApi] = [
      .setConfig,
      .setLeftContext,
      .createComposingTextInstance,
      .inputText,
      .deleteLeft,
      .deleteRight,
      .completePrefix,
      .moveCursor,
      .getHiraganaWithCursor,
      .getComposingString,
      .getCandidates,
    ]

  }

  struct SetConfigProps: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var zenzaiEnabled: Bool = false

    var zenzaiInferLimit: Int32 = 0

    var numberFullwidth: Int32 = 0

    var symbolFullwidth: Int32 = 0

    var periodStyle: Int32 = 0

    var commaStyle: Int32 = 0

    var spaceFullwidth: Int32 = 0

    var tenCombining: Int32 = 0

    var profileText: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetLeftContextProps: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var context: String = String()

    var anchor: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct InputTextProps: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var text: String = String()

    var isDirect: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MoveCursorProps: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var offset: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PrefixCompleteProps: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetComposingStringProps: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var charType: Hazkey_Commands_QueryData.GetComposingStringProps.CharType = .hiragana

    var currentPreedit: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum CharType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case hiragana // = 0
      case katakanaFull // = 1
      case katakanaHalf // = 2
      case alphabetFull // = 3
      case alphabetHalf // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .hiragana
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .hiragana
        case 1: self = .katakanaFull
        case 2: self = .katakanaHalf
        case 3: self = .alphabetFull
        case 4: self = .alphabetHalf
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .hiragana: return 0
        case .katakanaFull: return 1
        case .katakanaHalf: return 2
        case .alphabetFull: return 3
        case .alphabetHalf: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Hazkey_Commands_QueryData.GetComposingStringProps.CharType] = [
        .hiragana,
        .katakanaFull,
        .katakanaHalf,
        .alphabetFull,
        .alphabetHalf,
      ]

    }

    init() {}
  }

  struct GetCandidatesProps: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isPredictMode: Bool = false

    var nBest: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Hazkey_Commands_ResultData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Hazkey_Commands_ResultData.StatusCode = .success

  var errorMessage: String = String()

  var props: Hazkey_Commands_ResultData.OneOf_Props? = nil

  var result: String {
    get {
      if case .result(let v)? = props {return v}
      return String()
    }
    set {props = .result(newValue)}
  }

  var candidates: Hazkey_Commands_ResultData.CandidatesResult {
    get {
      if case .candidates(let v)? = props {return v}
      return Hazkey_Commands_ResultData.CandidatesResult()
    }
    set {props = .candidates(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Props: Equatable, Sendable {
    case result(String)
    case candidates(Hazkey_Commands_ResultData.CandidatesResult)

  }

  enum StatusCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case success // = 0
    case failed // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .success
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .success: return 0
      case .failed: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Hazkey_Commands_ResultData.StatusCode] = [
      .success,
      .failed,
    ]

  }

  struct CandidatesResult: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Hazkey_Commands_ResultData.StatusCode = .success

    var candidates: [Hazkey_Commands_ResultData.CandidatesResult.Candidate] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Candidate: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var text: String = String()

      var subHiragana: String = String()

      var liveCompat: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "hazkey.commands"

extension Hazkey_Commands_QueryData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "function"),
    2: .standard(proto: "set_config"),
    3: .standard(proto: "set_left_context"),
    4: .standard(proto: "input_text"),
    5: .standard(proto: "move_cursor"),
    6: .standard(proto: "complete_prefix"),
    7: .standard(proto: "get_composing_string"),
    8: .standard(proto: "get_candidates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.function) }()
      case 2: try {
        var v: Hazkey_Commands_QueryData.SetConfigProps?
        var hadOneofValue = false
        if let current = self.props {
          hadOneofValue = true
          if case .setConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.props = .setConfig(v)
        }
      }()
      case 3: try {
        var v: Hazkey_Commands_QueryData.SetLeftContextProps?
        var hadOneofValue = false
        if let current = self.props {
          hadOneofValue = true
          if case .setLeftContext(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.props = .setLeftContext(v)
        }
      }()
      case 4: try {
        var v: Hazkey_Commands_QueryData.InputTextProps?
        var hadOneofValue = false
        if let current = self.props {
          hadOneofValue = true
          if case .inputText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.props = .inputText(v)
        }
      }()
      case 5: try {
        var v: Hazkey_Commands_QueryData.MoveCursorProps?
        var hadOneofValue = false
        if let current = self.props {
          hadOneofValue = true
          if case .moveCursor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.props = .moveCursor(v)
        }
      }()
      case 6: try {
        var v: Hazkey_Commands_QueryData.PrefixCompleteProps?
        var hadOneofValue = false
        if let current = self.props {
          hadOneofValue = true
          if case .completePrefix(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.props = .completePrefix(v)
        }
      }()
      case 7: try {
        var v: Hazkey_Commands_QueryData.GetComposingStringProps?
        var hadOneofValue = false
        if let current = self.props {
          hadOneofValue = true
          if case .getComposingString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.props = .getComposingString(v)
        }
      }()
      case 8: try {
        var v: Hazkey_Commands_QueryData.GetCandidatesProps?
        var hadOneofValue = false
        if let current = self.props {
          hadOneofValue = true
          if case .getCandidates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.props = .getCandidates(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.function != .setConfig {
      try visitor.visitSingularEnumField(value: self.function, fieldNumber: 1)
    }
    switch self.props {
    case .setConfig?: try {
      guard case .setConfig(let v)? = self.props else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .setLeftContext?: try {
      guard case .setLeftContext(let v)? = self.props else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .inputText?: try {
      guard case .inputText(let v)? = self.props else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .moveCursor?: try {
      guard case .moveCursor(let v)? = self.props else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .completePrefix?: try {
      guard case .completePrefix(let v)? = self.props else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .getComposingString?: try {
      guard case .getComposingString(let v)? = self.props else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .getCandidates?: try {
      guard case .getCandidates(let v)? = self.props else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_QueryData, rhs: Hazkey_Commands_QueryData) -> Bool {
    if lhs.function != rhs.function {return false}
    if lhs.props != rhs.props {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_QueryData.KkcApi: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SET_CONFIG"),
    1: .same(proto: "SET_LEFT_CONTEXT"),
    2: .same(proto: "CREATE_COMPOSING_TEXT_INSTANCE"),
    3: .same(proto: "INPUT_TEXT"),
    4: .same(proto: "DELETE_LEFT"),
    5: .same(proto: "DELETE_RIGHT"),
    6: .same(proto: "COMPLETE_PREFIX"),
    7: .same(proto: "MOVE_CURSOR"),
    8: .same(proto: "GET_HIRAGANA_WITH_CURSOR"),
    9: .same(proto: "GET_COMPOSING_STRING"),
    10: .same(proto: "GET_CANDIDATES"),
  ]
}

extension Hazkey_Commands_QueryData.SetConfigProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Hazkey_Commands_QueryData.protoMessageName + ".SetConfigProps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "zenzai_enabled"),
    2: .standard(proto: "zenzai_infer_limit"),
    3: .standard(proto: "number_fullwidth"),
    4: .standard(proto: "symbol_fullwidth"),
    5: .standard(proto: "period_style"),
    6: .standard(proto: "comma_style"),
    7: .standard(proto: "space_fullwidth"),
    8: .standard(proto: "ten_combining"),
    9: .standard(proto: "profile_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.zenzaiEnabled) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.zenzaiInferLimit) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numberFullwidth) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.symbolFullwidth) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.periodStyle) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.commaStyle) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.spaceFullwidth) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.tenCombining) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.profileText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.zenzaiEnabled != false {
      try visitor.visitSingularBoolField(value: self.zenzaiEnabled, fieldNumber: 1)
    }
    if self.zenzaiInferLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.zenzaiInferLimit, fieldNumber: 2)
    }
    if self.numberFullwidth != 0 {
      try visitor.visitSingularInt32Field(value: self.numberFullwidth, fieldNumber: 3)
    }
    if self.symbolFullwidth != 0 {
      try visitor.visitSingularInt32Field(value: self.symbolFullwidth, fieldNumber: 4)
    }
    if self.periodStyle != 0 {
      try visitor.visitSingularInt32Field(value: self.periodStyle, fieldNumber: 5)
    }
    if self.commaStyle != 0 {
      try visitor.visitSingularInt32Field(value: self.commaStyle, fieldNumber: 6)
    }
    if self.spaceFullwidth != 0 {
      try visitor.visitSingularInt32Field(value: self.spaceFullwidth, fieldNumber: 7)
    }
    if self.tenCombining != 0 {
      try visitor.visitSingularInt32Field(value: self.tenCombining, fieldNumber: 8)
    }
    if !self.profileText.isEmpty {
      try visitor.visitSingularStringField(value: self.profileText, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_QueryData.SetConfigProps, rhs: Hazkey_Commands_QueryData.SetConfigProps) -> Bool {
    if lhs.zenzaiEnabled != rhs.zenzaiEnabled {return false}
    if lhs.zenzaiInferLimit != rhs.zenzaiInferLimit {return false}
    if lhs.numberFullwidth != rhs.numberFullwidth {return false}
    if lhs.symbolFullwidth != rhs.symbolFullwidth {return false}
    if lhs.periodStyle != rhs.periodStyle {return false}
    if lhs.commaStyle != rhs.commaStyle {return false}
    if lhs.spaceFullwidth != rhs.spaceFullwidth {return false}
    if lhs.tenCombining != rhs.tenCombining {return false}
    if lhs.profileText != rhs.profileText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_QueryData.SetLeftContextProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Hazkey_Commands_QueryData.protoMessageName + ".SetLeftContextProps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "anchor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.context) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.anchor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 1)
    }
    if self.anchor != 0 {
      try visitor.visitSingularInt32Field(value: self.anchor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_QueryData.SetLeftContextProps, rhs: Hazkey_Commands_QueryData.SetLeftContextProps) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.anchor != rhs.anchor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_QueryData.InputTextProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Hazkey_Commands_QueryData.protoMessageName + ".InputTextProps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "is_direct"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isDirect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.isDirect != false {
      try visitor.visitSingularBoolField(value: self.isDirect, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_QueryData.InputTextProps, rhs: Hazkey_Commands_QueryData.InputTextProps) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.isDirect != rhs.isDirect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_QueryData.MoveCursorProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Hazkey_Commands_QueryData.protoMessageName + ".MoveCursorProps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_QueryData.MoveCursorProps, rhs: Hazkey_Commands_QueryData.MoveCursorProps) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_QueryData.PrefixCompleteProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Hazkey_Commands_QueryData.protoMessageName + ".PrefixCompleteProps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_QueryData.PrefixCompleteProps, rhs: Hazkey_Commands_QueryData.PrefixCompleteProps) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_QueryData.GetComposingStringProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Hazkey_Commands_QueryData.protoMessageName + ".GetComposingStringProps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "char_type"),
    2: .standard(proto: "current_preedit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.charType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currentPreedit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.charType != .hiragana {
      try visitor.visitSingularEnumField(value: self.charType, fieldNumber: 1)
    }
    if !self.currentPreedit.isEmpty {
      try visitor.visitSingularStringField(value: self.currentPreedit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_QueryData.GetComposingStringProps, rhs: Hazkey_Commands_QueryData.GetComposingStringProps) -> Bool {
    if lhs.charType != rhs.charType {return false}
    if lhs.currentPreedit != rhs.currentPreedit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_QueryData.GetComposingStringProps.CharType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HIRAGANA"),
    1: .same(proto: "KATAKANA_FULL"),
    2: .same(proto: "KATAKANA_HALF"),
    3: .same(proto: "ALPHABET_FULL"),
    4: .same(proto: "ALPHABET_HALF"),
  ]
}

extension Hazkey_Commands_QueryData.GetCandidatesProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Hazkey_Commands_QueryData.protoMessageName + ".GetCandidatesProps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_predict_mode"),
    2: .standard(proto: "n_best"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isPredictMode) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.nBest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isPredictMode != false {
      try visitor.visitSingularBoolField(value: self.isPredictMode, fieldNumber: 1)
    }
    if self.nBest != 0 {
      try visitor.visitSingularInt32Field(value: self.nBest, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_QueryData.GetCandidatesProps, rhs: Hazkey_Commands_QueryData.GetCandidatesProps) -> Bool {
    if lhs.isPredictMode != rhs.isPredictMode {return false}
    if lhs.nBest != rhs.nBest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_ResultData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResultData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "errorMessage"),
    3: .same(proto: "result"),
    4: .same(proto: "candidates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.props != nil {try decoder.handleConflictingOneOf()}
          self.props = .result(v)
        }
      }()
      case 4: try {
        var v: Hazkey_Commands_ResultData.CandidatesResult?
        var hadOneofValue = false
        if let current = self.props {
          hadOneofValue = true
          if case .candidates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.props = .candidates(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    switch self.props {
    case .result?: try {
      guard case .result(let v)? = self.props else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .candidates?: try {
      guard case .candidates(let v)? = self.props else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_ResultData, rhs: Hazkey_Commands_ResultData) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.props != rhs.props {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_ResultData.StatusCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCESS"),
    1: .same(proto: "FAILED"),
  ]
}

extension Hazkey_Commands_ResultData.CandidatesResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Hazkey_Commands_ResultData.protoMessageName + ".CandidatesResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "candidates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.candidates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.candidates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candidates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_ResultData.CandidatesResult, rhs: Hazkey_Commands_ResultData.CandidatesResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.candidates != rhs.candidates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hazkey_Commands_ResultData.CandidatesResult.Candidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Hazkey_Commands_ResultData.CandidatesResult.protoMessageName + ".Candidate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "sub_hiragana"),
    3: .standard(proto: "live_compat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subHiragana) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.liveCompat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.subHiragana.isEmpty {
      try visitor.visitSingularStringField(value: self.subHiragana, fieldNumber: 2)
    }
    if self.liveCompat != false {
      try visitor.visitSingularBoolField(value: self.liveCompat, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Hazkey_Commands_ResultData.CandidatesResult.Candidate, rhs: Hazkey_Commands_ResultData.CandidatesResult.Candidate) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.subHiragana != rhs.subHiragana {return false}
    if lhs.liveCompat != rhs.liveCompat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
