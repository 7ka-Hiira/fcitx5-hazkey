// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: table.proto
// Protobuf C++ Version: 6.31.1

#ifndef table_2eproto_2epb_2eh
#define table_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_table_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_table_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_table_2eproto;
}  // extern "C"
namespace hazkey {
namespace config {
namespace table {
class EditOperation;
struct EditOperationDefaultTypeInternal;
extern EditOperationDefaultTypeInternal _EditOperation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EditOperation_class_data_;
class EditOperation_Create;
struct EditOperation_CreateDefaultTypeInternal;
extern EditOperation_CreateDefaultTypeInternal _EditOperation_Create_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EditOperation_Create_class_data_;
class EditOperation_Delete;
struct EditOperation_DeleteDefaultTypeInternal;
extern EditOperation_DeleteDefaultTypeInternal _EditOperation_Delete_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EditOperation_Delete_class_data_;
class EditOperation_Dupicate;
struct EditOperation_DupicateDefaultTypeInternal;
extern EditOperation_DupicateDefaultTypeInternal _EditOperation_Dupicate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EditOperation_Dupicate_class_data_;
class EditOperation_Rename;
struct EditOperation_RenameDefaultTypeInternal;
extern EditOperation_RenameDefaultTypeInternal _EditOperation_Rename_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EditOperation_Rename_class_data_;
class EditOperation_Update;
struct EditOperation_UpdateDefaultTypeInternal;
extern EditOperation_UpdateDefaultTypeInternal _EditOperation_Update_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EditOperation_Update_class_data_;
class InputTable;
struct InputTableDefaultTypeInternal;
extern InputTableDefaultTypeInternal _InputTable_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InputTable_class_data_;
class InputTable_InputTableEntry;
struct InputTable_InputTableEntryDefaultTypeInternal;
extern InputTable_InputTableEntryDefaultTypeInternal _InputTable_InputTableEntry_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InputTable_InputTableEntry_class_data_;
class InputTable_InputTableMeta;
struct InputTable_InputTableMetaDefaultTypeInternal;
extern InputTable_InputTableMetaDefaultTypeInternal _InputTable_InputTableMeta_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InputTable_InputTableMeta_class_data_;
}  // namespace table
}  // namespace config
}  // namespace hazkey
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace hazkey {
namespace config {
namespace table {

// ===================================================================


// -------------------------------------------------------------------

class InputTable_InputTableMeta final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.config.table.InputTable.InputTableMeta) */ {
 public:
  inline InputTable_InputTableMeta() : InputTable_InputTableMeta(nullptr) {}
  ~InputTable_InputTableMeta() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InputTable_InputTableMeta* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InputTable_InputTableMeta));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputTable_InputTableMeta(::google::protobuf::internal::ConstantInitialized);

  inline InputTable_InputTableMeta(const InputTable_InputTableMeta& from) : InputTable_InputTableMeta(nullptr, from) {}
  inline InputTable_InputTableMeta(InputTable_InputTableMeta&& from) noexcept
      : InputTable_InputTableMeta(nullptr, ::std::move(from)) {}
  inline InputTable_InputTableMeta& operator=(const InputTable_InputTableMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputTable_InputTableMeta& operator=(InputTable_InputTableMeta&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputTable_InputTableMeta& default_instance() {
    return *reinterpret_cast<const InputTable_InputTableMeta*>(
        &_InputTable_InputTableMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(InputTable_InputTableMeta& a, InputTable_InputTableMeta& b) { a.Swap(&b); }
  inline void Swap(InputTable_InputTableMeta* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputTable_InputTableMeta* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputTable_InputTableMeta* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InputTable_InputTableMeta>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputTable_InputTableMeta& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputTable_InputTableMeta& from) { InputTable_InputTableMeta::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InputTable_InputTableMeta* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.config.table.InputTable.InputTableMeta"; }

 protected:
  explicit InputTable_InputTableMeta(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InputTable_InputTableMeta(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InputTable_InputTableMeta& from);
  InputTable_InputTableMeta(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InputTable_InputTableMeta&& from) noexcept
      : InputTable_InputTableMeta(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kFilenameFieldNumber = 3,
    kIsDefaultFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string filename = 3;
  void clear_filename() ;
  const ::std::string& filename() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_filename(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_filename();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_filename();
  void set_allocated_filename(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_filename() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_filename();

  public:
  // bool is_default = 2;
  void clear_is_default() ;
  bool is_default() const;
  void set_is_default(bool value);

  private:
  bool _internal_is_default() const;
  void _internal_set_is_default(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.config.table.InputTable.InputTableMeta)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 66,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InputTable_InputTableMeta& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr filename_;
    bool is_default_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InputTable_InputTableMeta_class_data_;
// -------------------------------------------------------------------

class InputTable_InputTableEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.config.table.InputTable.InputTableEntry) */ {
 public:
  inline InputTable_InputTableEntry() : InputTable_InputTableEntry(nullptr) {}
  ~InputTable_InputTableEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InputTable_InputTableEntry* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InputTable_InputTableEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputTable_InputTableEntry(::google::protobuf::internal::ConstantInitialized);

  inline InputTable_InputTableEntry(const InputTable_InputTableEntry& from) : InputTable_InputTableEntry(nullptr, from) {}
  inline InputTable_InputTableEntry(InputTable_InputTableEntry&& from) noexcept
      : InputTable_InputTableEntry(nullptr, ::std::move(from)) {}
  inline InputTable_InputTableEntry& operator=(const InputTable_InputTableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputTable_InputTableEntry& operator=(InputTable_InputTableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputTable_InputTableEntry& default_instance() {
    return *reinterpret_cast<const InputTable_InputTableEntry*>(
        &_InputTable_InputTableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(InputTable_InputTableEntry& a, InputTable_InputTableEntry& b) { a.Swap(&b); }
  inline void Swap(InputTable_InputTableEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputTable_InputTableEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputTable_InputTableEntry* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InputTable_InputTableEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputTable_InputTableEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputTable_InputTableEntry& from) { InputTable_InputTableEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InputTable_InputTableEntry* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.config.table.InputTable.InputTableEntry"; }

 protected:
  explicit InputTable_InputTableEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InputTable_InputTableEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InputTable_InputTableEntry& from);
  InputTable_InputTableEntry(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InputTable_InputTableEntry&& from) noexcept
      : InputTable_InputTableEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputFieldNumber = 1,
    kOutputFieldNumber = 2,
  };
  // string input = 1;
  void clear_input() ;
  const ::std::string& input() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_input(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_input();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_input();
  void set_allocated_input(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_input() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_input(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_input();

  public:
  // string output = 2;
  void clear_output() ;
  const ::std::string& output() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_output(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_output();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_output();
  void set_allocated_output(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_output() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_output(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_output();

  public:
  // @@protoc_insertion_point(class_scope:hazkey.config.table.InputTable.InputTableEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 66,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InputTable_InputTableEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr input_;
    ::google::protobuf::internal::ArenaStringPtr output_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InputTable_InputTableEntry_class_data_;
// -------------------------------------------------------------------

class EditOperation_Rename final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.config.table.EditOperation.Rename) */ {
 public:
  inline EditOperation_Rename() : EditOperation_Rename(nullptr) {}
  ~EditOperation_Rename() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EditOperation_Rename* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EditOperation_Rename));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EditOperation_Rename(::google::protobuf::internal::ConstantInitialized);

  inline EditOperation_Rename(const EditOperation_Rename& from) : EditOperation_Rename(nullptr, from) {}
  inline EditOperation_Rename(EditOperation_Rename&& from) noexcept
      : EditOperation_Rename(nullptr, ::std::move(from)) {}
  inline EditOperation_Rename& operator=(const EditOperation_Rename& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditOperation_Rename& operator=(EditOperation_Rename&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditOperation_Rename& default_instance() {
    return *reinterpret_cast<const EditOperation_Rename*>(
        &_EditOperation_Rename_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(EditOperation_Rename& a, EditOperation_Rename& b) { a.Swap(&b); }
  inline void Swap(EditOperation_Rename* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditOperation_Rename* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditOperation_Rename* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EditOperation_Rename>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EditOperation_Rename& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EditOperation_Rename& from) { EditOperation_Rename::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EditOperation_Rename* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.config.table.EditOperation.Rename"; }

 protected:
  explicit EditOperation_Rename(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EditOperation_Rename(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EditOperation_Rename& from);
  EditOperation_Rename(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EditOperation_Rename&& from) noexcept
      : EditOperation_Rename(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameOldFieldNumber = 1,
    kNameNewFieldNumber = 3,
    kIsDefaultFieldNumber = 2,
  };
  // string name_old = 1;
  void clear_name_old() ;
  const ::std::string& name_old() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name_old(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name_old();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name_old();
  void set_allocated_name_old(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name_old() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name_old(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name_old();

  public:
  // string name_new = 3;
  void clear_name_new() ;
  const ::std::string& name_new() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name_new(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name_new();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name_new();
  void set_allocated_name_new(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name_new() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name_new(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name_new();

  public:
  // bool is_default = 2;
  void clear_is_default() ;
  bool is_default() const;
  void set_is_default(bool value);

  private:
  bool _internal_is_default() const;
  void _internal_set_is_default(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.config.table.EditOperation.Rename)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 65,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EditOperation_Rename& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_old_;
    ::google::protobuf::internal::ArenaStringPtr name_new_;
    bool is_default_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EditOperation_Rename_class_data_;
// -------------------------------------------------------------------

class EditOperation_Dupicate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.config.table.EditOperation.Dupicate) */ {
 public:
  inline EditOperation_Dupicate() : EditOperation_Dupicate(nullptr) {}
  ~EditOperation_Dupicate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EditOperation_Dupicate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EditOperation_Dupicate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EditOperation_Dupicate(::google::protobuf::internal::ConstantInitialized);

  inline EditOperation_Dupicate(const EditOperation_Dupicate& from) : EditOperation_Dupicate(nullptr, from) {}
  inline EditOperation_Dupicate(EditOperation_Dupicate&& from) noexcept
      : EditOperation_Dupicate(nullptr, ::std::move(from)) {}
  inline EditOperation_Dupicate& operator=(const EditOperation_Dupicate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditOperation_Dupicate& operator=(EditOperation_Dupicate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditOperation_Dupicate& default_instance() {
    return *reinterpret_cast<const EditOperation_Dupicate*>(
        &_EditOperation_Dupicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(EditOperation_Dupicate& a, EditOperation_Dupicate& b) { a.Swap(&b); }
  inline void Swap(EditOperation_Dupicate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditOperation_Dupicate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditOperation_Dupicate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EditOperation_Dupicate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EditOperation_Dupicate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EditOperation_Dupicate& from) { EditOperation_Dupicate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EditOperation_Dupicate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.config.table.EditOperation.Dupicate"; }

 protected:
  explicit EditOperation_Dupicate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EditOperation_Dupicate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EditOperation_Dupicate& from);
  EditOperation_Dupicate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EditOperation_Dupicate&& from) noexcept
      : EditOperation_Dupicate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceNameFieldNumber = 1,
    kNewNameFieldNumber = 3,
    kSourceIsDefaultFieldNumber = 2,
  };
  // string source_name = 1;
  void clear_source_name() ;
  const ::std::string& source_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_source_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_source_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_source_name();
  void set_allocated_source_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_source_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_source_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_source_name();

  public:
  // string new_name = 3;
  void clear_new_name() ;
  const ::std::string& new_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_new_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_new_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_new_name();
  void set_allocated_new_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_new_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_new_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_new_name();

  public:
  // bool source_is_default = 2;
  void clear_source_is_default() ;
  bool source_is_default() const;
  void set_source_is_default(bool value);

  private:
  bool _internal_source_is_default() const;
  void _internal_set_source_is_default(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.config.table.EditOperation.Dupicate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EditOperation_Dupicate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr source_name_;
    ::google::protobuf::internal::ArenaStringPtr new_name_;
    bool source_is_default_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EditOperation_Dupicate_class_data_;
// -------------------------------------------------------------------

class EditOperation_Delete final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.config.table.EditOperation.Delete) */ {
 public:
  inline EditOperation_Delete() : EditOperation_Delete(nullptr) {}
  ~EditOperation_Delete() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EditOperation_Delete* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EditOperation_Delete));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EditOperation_Delete(::google::protobuf::internal::ConstantInitialized);

  inline EditOperation_Delete(const EditOperation_Delete& from) : EditOperation_Delete(nullptr, from) {}
  inline EditOperation_Delete(EditOperation_Delete&& from) noexcept
      : EditOperation_Delete(nullptr, ::std::move(from)) {}
  inline EditOperation_Delete& operator=(const EditOperation_Delete& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditOperation_Delete& operator=(EditOperation_Delete&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditOperation_Delete& default_instance() {
    return *reinterpret_cast<const EditOperation_Delete*>(
        &_EditOperation_Delete_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(EditOperation_Delete& a, EditOperation_Delete& b) { a.Swap(&b); }
  inline void Swap(EditOperation_Delete* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditOperation_Delete* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditOperation_Delete* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EditOperation_Delete>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EditOperation_Delete& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EditOperation_Delete& from) { EditOperation_Delete::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EditOperation_Delete* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.config.table.EditOperation.Delete"; }

 protected:
  explicit EditOperation_Delete(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EditOperation_Delete(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EditOperation_Delete& from);
  EditOperation_Delete(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EditOperation_Delete&& from) noexcept
      : EditOperation_Delete(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kIsDefaultFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // bool is_default = 2;
  void clear_is_default() ;
  bool is_default() const;
  void set_is_default(bool value);

  private:
  bool _internal_is_default() const;
  void _internal_set_is_default(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.config.table.EditOperation.Delete)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EditOperation_Delete& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    bool is_default_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EditOperation_Delete_class_data_;
// -------------------------------------------------------------------

class EditOperation_Create final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.config.table.EditOperation.Create) */ {
 public:
  inline EditOperation_Create() : EditOperation_Create(nullptr) {}
  ~EditOperation_Create() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EditOperation_Create* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EditOperation_Create));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EditOperation_Create(::google::protobuf::internal::ConstantInitialized);

  inline EditOperation_Create(const EditOperation_Create& from) : EditOperation_Create(nullptr, from) {}
  inline EditOperation_Create(EditOperation_Create&& from) noexcept
      : EditOperation_Create(nullptr, ::std::move(from)) {}
  inline EditOperation_Create& operator=(const EditOperation_Create& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditOperation_Create& operator=(EditOperation_Create&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditOperation_Create& default_instance() {
    return *reinterpret_cast<const EditOperation_Create*>(
        &_EditOperation_Create_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(EditOperation_Create& a, EditOperation_Create& b) { a.Swap(&b); }
  inline void Swap(EditOperation_Create* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditOperation_Create* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditOperation_Create* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EditOperation_Create>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EditOperation_Create& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EditOperation_Create& from) { EditOperation_Create::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EditOperation_Create* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.config.table.EditOperation.Create"; }

 protected:
  explicit EditOperation_Create(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EditOperation_Create(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EditOperation_Create& from);
  EditOperation_Create(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EditOperation_Create&& from) noexcept
      : EditOperation_Create(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewNameFieldNumber = 1,
  };
  // string new_name = 1;
  void clear_new_name() ;
  const ::std::string& new_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_new_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_new_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_new_name();
  void set_allocated_new_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_new_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_new_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_new_name();

  public:
  // @@protoc_insertion_point(class_scope:hazkey.config.table.EditOperation.Create)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EditOperation_Create& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr new_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EditOperation_Create_class_data_;
// -------------------------------------------------------------------

class InputTable final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.config.table.InputTable) */ {
 public:
  inline InputTable() : InputTable(nullptr) {}
  ~InputTable() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InputTable* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InputTable));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputTable(::google::protobuf::internal::ConstantInitialized);

  inline InputTable(const InputTable& from) : InputTable(nullptr, from) {}
  inline InputTable(InputTable&& from) noexcept
      : InputTable(nullptr, ::std::move(from)) {}
  inline InputTable& operator=(const InputTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputTable& operator=(InputTable&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputTable& default_instance() {
    return *reinterpret_cast<const InputTable*>(
        &_InputTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(InputTable& a, InputTable& b) { a.Swap(&b); }
  inline void Swap(InputTable* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputTable* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputTable* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InputTable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputTable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputTable& from) { InputTable::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InputTable* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.config.table.InputTable"; }

 protected:
  explicit InputTable(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InputTable(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InputTable& from);
  InputTable(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InputTable&& from) noexcept
      : InputTable(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using InputTableEntry = InputTable_InputTableEntry;
  using InputTableMeta = InputTable_InputTableMeta;

  // accessors -------------------------------------------------------
  enum : int {
    kMetaFieldNumber = 1,
    kInputTableFieldNumber = 2,
  };
  // repeated .hazkey.config.table.InputTable.InputTableMeta meta = 1;
  int meta_size() const;
  private:
  int _internal_meta_size() const;

  public:
  void clear_meta() ;
  ::hazkey::config::table::InputTable_InputTableMeta* PROTOBUF_NONNULL mutable_meta(int index);
  ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableMeta>* PROTOBUF_NONNULL mutable_meta();

  private:
  const ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableMeta>& _internal_meta() const;
  ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableMeta>* PROTOBUF_NONNULL _internal_mutable_meta();
  public:
  const ::hazkey::config::table::InputTable_InputTableMeta& meta(int index) const;
  ::hazkey::config::table::InputTable_InputTableMeta* PROTOBUF_NONNULL add_meta();
  const ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableMeta>& meta() const;
  // repeated .hazkey.config.table.InputTable.InputTableEntry input_table = 2;
  int input_table_size() const;
  private:
  int _internal_input_table_size() const;

  public:
  void clear_input_table() ;
  ::hazkey::config::table::InputTable_InputTableEntry* PROTOBUF_NONNULL mutable_input_table(int index);
  ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableEntry>* PROTOBUF_NONNULL mutable_input_table();

  private:
  const ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableEntry>& _internal_input_table() const;
  ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableEntry>* PROTOBUF_NONNULL _internal_mutable_input_table();
  public:
  const ::hazkey::config::table::InputTable_InputTableEntry& input_table(int index) const;
  ::hazkey::config::table::InputTable_InputTableEntry* PROTOBUF_NONNULL add_input_table();
  const ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableEntry>& input_table() const;
  // @@protoc_insertion_point(class_scope:hazkey.config.table.InputTable)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InputTable& from_msg);
    ::google::protobuf::RepeatedPtrField< ::hazkey::config::table::InputTable_InputTableMeta > meta_;
    ::google::protobuf::RepeatedPtrField< ::hazkey::config::table::InputTable_InputTableEntry > input_table_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InputTable_class_data_;
// -------------------------------------------------------------------

class EditOperation_Update final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.config.table.EditOperation.Update) */ {
 public:
  inline EditOperation_Update() : EditOperation_Update(nullptr) {}
  ~EditOperation_Update() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EditOperation_Update* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EditOperation_Update));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EditOperation_Update(::google::protobuf::internal::ConstantInitialized);

  inline EditOperation_Update(const EditOperation_Update& from) : EditOperation_Update(nullptr, from) {}
  inline EditOperation_Update(EditOperation_Update&& from) noexcept
      : EditOperation_Update(nullptr, ::std::move(from)) {}
  inline EditOperation_Update& operator=(const EditOperation_Update& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditOperation_Update& operator=(EditOperation_Update&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditOperation_Update& default_instance() {
    return *reinterpret_cast<const EditOperation_Update*>(
        &_EditOperation_Update_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(EditOperation_Update& a, EditOperation_Update& b) { a.Swap(&b); }
  inline void Swap(EditOperation_Update* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditOperation_Update* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditOperation_Update* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EditOperation_Update>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EditOperation_Update& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EditOperation_Update& from) { EditOperation_Update::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EditOperation_Update* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.config.table.EditOperation.Update"; }

 protected:
  explicit EditOperation_Update(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EditOperation_Update(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EditOperation_Update& from);
  EditOperation_Update(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EditOperation_Update&& from) noexcept
      : EditOperation_Update(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputTableFieldNumber = 1,
  };
  // .hazkey.config.table.InputTable InputTable = 1;
  bool has_inputtable() const;
  void clear_inputtable() ;
  const ::hazkey::config::table::InputTable& inputtable() const;
  [[nodiscard]] ::hazkey::config::table::InputTable* PROTOBUF_NULLABLE release_inputtable();
  ::hazkey::config::table::InputTable* PROTOBUF_NONNULL mutable_inputtable();
  void set_allocated_inputtable(::hazkey::config::table::InputTable* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_inputtable(::hazkey::config::table::InputTable* PROTOBUF_NULLABLE value);
  ::hazkey::config::table::InputTable* PROTOBUF_NULLABLE unsafe_arena_release_inputtable();

  private:
  const ::hazkey::config::table::InputTable& _internal_inputtable() const;
  ::hazkey::config::table::InputTable* PROTOBUF_NONNULL _internal_mutable_inputtable();

  public:
  // @@protoc_insertion_point(class_scope:hazkey.config.table.EditOperation.Update)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EditOperation_Update& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::hazkey::config::table::InputTable* PROTOBUF_NULLABLE inputtable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EditOperation_Update_class_data_;
// -------------------------------------------------------------------

class EditOperation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.config.table.EditOperation) */ {
 public:
  inline EditOperation() : EditOperation(nullptr) {}
  ~EditOperation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EditOperation* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EditOperation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EditOperation(::google::protobuf::internal::ConstantInitialized);

  inline EditOperation(const EditOperation& from) : EditOperation(nullptr, from) {}
  inline EditOperation(EditOperation&& from) noexcept
      : EditOperation(nullptr, ::std::move(from)) {}
  inline EditOperation& operator=(const EditOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditOperation& operator=(EditOperation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditOperation& default_instance() {
    return *reinterpret_cast<const EditOperation*>(
        &_EditOperation_default_instance_);
  }
  enum OperationCase {
    kRename = 1,
    kDelete = 2,
    kCreate = 3,
    kDupicate = 4,
    kUpdate = 5,
    OPERATION_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(EditOperation& a, EditOperation& b) { a.Swap(&b); }
  inline void Swap(EditOperation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditOperation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditOperation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EditOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EditOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EditOperation& from) { EditOperation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EditOperation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.config.table.EditOperation"; }

 protected:
  explicit EditOperation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EditOperation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EditOperation& from);
  EditOperation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EditOperation&& from) noexcept
      : EditOperation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Rename = EditOperation_Rename;
  using Delete = EditOperation_Delete;
  using Create = EditOperation_Create;
  using Dupicate = EditOperation_Dupicate;
  using Update = EditOperation_Update;

  // accessors -------------------------------------------------------
  enum : int {
    kRenameFieldNumber = 1,
    kDeleteFieldNumber = 2,
    kCreateFieldNumber = 3,
    kDupicateFieldNumber = 4,
    kUpdateFieldNumber = 5,
  };
  // .hazkey.config.table.EditOperation.Rename rename = 1;
  bool has_rename() const;
  private:
  bool _internal_has_rename() const;

  public:
  void clear_rename() ;
  const ::hazkey::config::table::EditOperation_Rename& rename() const;
  [[nodiscard]] ::hazkey::config::table::EditOperation_Rename* PROTOBUF_NULLABLE release_rename();
  ::hazkey::config::table::EditOperation_Rename* PROTOBUF_NONNULL mutable_rename();
  void set_allocated_rename(::hazkey::config::table::EditOperation_Rename* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rename(::hazkey::config::table::EditOperation_Rename* PROTOBUF_NULLABLE value);
  ::hazkey::config::table::EditOperation_Rename* PROTOBUF_NULLABLE unsafe_arena_release_rename();

  private:
  const ::hazkey::config::table::EditOperation_Rename& _internal_rename() const;
  ::hazkey::config::table::EditOperation_Rename* PROTOBUF_NONNULL _internal_mutable_rename();

  public:
  // .hazkey.config.table.EditOperation.Delete delete = 2;
  bool has_delete_() const;
  private:
  bool _internal_has_delete_() const;

  public:
  void clear_delete_() ;
  const ::hazkey::config::table::EditOperation_Delete& delete_() const;
  [[nodiscard]] ::hazkey::config::table::EditOperation_Delete* PROTOBUF_NULLABLE release_delete_();
  ::hazkey::config::table::EditOperation_Delete* PROTOBUF_NONNULL mutable_delete_();
  void set_allocated_delete_(::hazkey::config::table::EditOperation_Delete* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_delete_(::hazkey::config::table::EditOperation_Delete* PROTOBUF_NULLABLE value);
  ::hazkey::config::table::EditOperation_Delete* PROTOBUF_NULLABLE unsafe_arena_release_delete_();

  private:
  const ::hazkey::config::table::EditOperation_Delete& _internal_delete_() const;
  ::hazkey::config::table::EditOperation_Delete* PROTOBUF_NONNULL _internal_mutable_delete_();

  public:
  // .hazkey.config.table.EditOperation.Create create = 3;
  bool has_create() const;
  private:
  bool _internal_has_create() const;

  public:
  void clear_create() ;
  const ::hazkey::config::table::EditOperation_Create& create() const;
  [[nodiscard]] ::hazkey::config::table::EditOperation_Create* PROTOBUF_NULLABLE release_create();
  ::hazkey::config::table::EditOperation_Create* PROTOBUF_NONNULL mutable_create();
  void set_allocated_create(::hazkey::config::table::EditOperation_Create* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_create(::hazkey::config::table::EditOperation_Create* PROTOBUF_NULLABLE value);
  ::hazkey::config::table::EditOperation_Create* PROTOBUF_NULLABLE unsafe_arena_release_create();

  private:
  const ::hazkey::config::table::EditOperation_Create& _internal_create() const;
  ::hazkey::config::table::EditOperation_Create* PROTOBUF_NONNULL _internal_mutable_create();

  public:
  // .hazkey.config.table.EditOperation.Dupicate dupicate = 4;
  bool has_dupicate() const;
  private:
  bool _internal_has_dupicate() const;

  public:
  void clear_dupicate() ;
  const ::hazkey::config::table::EditOperation_Dupicate& dupicate() const;
  [[nodiscard]] ::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NULLABLE release_dupicate();
  ::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NONNULL mutable_dupicate();
  void set_allocated_dupicate(::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dupicate(::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NULLABLE value);
  ::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NULLABLE unsafe_arena_release_dupicate();

  private:
  const ::hazkey::config::table::EditOperation_Dupicate& _internal_dupicate() const;
  ::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NONNULL _internal_mutable_dupicate();

  public:
  // .hazkey.config.table.EditOperation.Update update = 5;
  bool has_update() const;
  private:
  bool _internal_has_update() const;

  public:
  void clear_update() ;
  const ::hazkey::config::table::EditOperation_Update& update() const;
  [[nodiscard]] ::hazkey::config::table::EditOperation_Update* PROTOBUF_NULLABLE release_update();
  ::hazkey::config::table::EditOperation_Update* PROTOBUF_NONNULL mutable_update();
  void set_allocated_update(::hazkey::config::table::EditOperation_Update* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update(::hazkey::config::table::EditOperation_Update* PROTOBUF_NULLABLE value);
  ::hazkey::config::table::EditOperation_Update* PROTOBUF_NULLABLE unsafe_arena_release_update();

  private:
  const ::hazkey::config::table::EditOperation_Update& _internal_update() const;
  ::hazkey::config::table::EditOperation_Update* PROTOBUF_NONNULL _internal_mutable_update();

  public:
  void clear_operation();
  OperationCase operation_case() const;
  // @@protoc_insertion_point(class_scope:hazkey.config.table.EditOperation)
 private:
  class _Internal;
  void set_has_rename();
  void set_has_delete_();
  void set_has_create();
  void set_has_dupicate();
  void set_has_update();
  inline bool has_operation() const;
  inline void clear_has_operation();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 5,
                                   5, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EditOperation& from_msg);
    union OperationUnion {
      constexpr OperationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE rename_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE delete__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE create_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE dupicate_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE update_;
    } operation_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EditOperation_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InputTable_InputTableEntry

// string input = 1;
inline void InputTable_InputTableEntry::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InputTable_InputTableEntry::input() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.InputTable.InputTableEntry.input)
  return _internal_input();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InputTable_InputTableEntry::set_input(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.input_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.InputTable.InputTableEntry.input)
}
inline ::std::string* PROTOBUF_NONNULL InputTable_InputTableEntry::mutable_input()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.InputTable.InputTableEntry.input)
  return _s;
}
inline const ::std::string& InputTable_InputTableEntry::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_.Get();
}
inline void InputTable_InputTableEntry::_internal_set_input(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.input_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InputTable_InputTableEntry::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.input_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InputTable_InputTableEntry::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.InputTable.InputTableEntry.input)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.input_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.input_.Set("", GetArena());
  }
  return released;
}
inline void InputTable_InputTableEntry::set_allocated_input(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.input_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.input_.IsDefault()) {
    _impl_.input_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.InputTable.InputTableEntry.input)
}

// string output = 2;
inline void InputTable_InputTableEntry::clear_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& InputTable_InputTableEntry::output() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.InputTable.InputTableEntry.output)
  return _internal_output();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InputTable_InputTableEntry::set_output(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.output_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.InputTable.InputTableEntry.output)
}
inline ::std::string* PROTOBUF_NONNULL InputTable_InputTableEntry::mutable_output()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.InputTable.InputTableEntry.output)
  return _s;
}
inline const ::std::string& InputTable_InputTableEntry::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_.Get();
}
inline void InputTable_InputTableEntry::_internal_set_output(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.output_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InputTable_InputTableEntry::_internal_mutable_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.output_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InputTable_InputTableEntry::release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.InputTable.InputTableEntry.output)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.output_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.output_.Set("", GetArena());
  }
  return released;
}
inline void InputTable_InputTableEntry::set_allocated_output(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.output_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.InputTable.InputTableEntry.output)
}

// -------------------------------------------------------------------

// InputTable_InputTableMeta

// string name = 1;
inline void InputTable_InputTableMeta::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InputTable_InputTableMeta::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.InputTable.InputTableMeta.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InputTable_InputTableMeta::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.InputTable.InputTableMeta.name)
}
inline ::std::string* PROTOBUF_NONNULL InputTable_InputTableMeta::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.InputTable.InputTableMeta.name)
  return _s;
}
inline const ::std::string& InputTable_InputTableMeta::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void InputTable_InputTableMeta::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InputTable_InputTableMeta::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InputTable_InputTableMeta::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.InputTable.InputTableMeta.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void InputTable_InputTableMeta::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.InputTable.InputTableMeta.name)
}

// bool is_default = 2;
inline void InputTable_InputTableMeta::clear_is_default() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool InputTable_InputTableMeta::is_default() const {
  // @@protoc_insertion_point(field_get:hazkey.config.table.InputTable.InputTableMeta.is_default)
  return _internal_is_default();
}
inline void InputTable_InputTableMeta::set_is_default(bool value) {
  _internal_set_is_default(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:hazkey.config.table.InputTable.InputTableMeta.is_default)
}
inline bool InputTable_InputTableMeta::_internal_is_default() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_default_;
}
inline void InputTable_InputTableMeta::_internal_set_is_default(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = value;
}

// string filename = 3;
inline void InputTable_InputTableMeta::clear_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& InputTable_InputTableMeta::filename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.InputTable.InputTableMeta.filename)
  return _internal_filename();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InputTable_InputTableMeta::set_filename(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.InputTable.InputTableMeta.filename)
}
inline ::std::string* PROTOBUF_NONNULL InputTable_InputTableMeta::mutable_filename()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.InputTable.InputTableMeta.filename)
  return _s;
}
inline const ::std::string& InputTable_InputTableMeta::_internal_filename() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filename_.Get();
}
inline void InputTable_InputTableMeta::_internal_set_filename(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filename_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InputTable_InputTableMeta::_internal_mutable_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.filename_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InputTable_InputTableMeta::release_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.InputTable.InputTableMeta.filename)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.filename_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filename_.Set("", GetArena());
  }
  return released;
}
inline void InputTable_InputTableMeta::set_allocated_filename(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filename_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.InputTable.InputTableMeta.filename)
}

// -------------------------------------------------------------------

// InputTable

// repeated .hazkey.config.table.InputTable.InputTableMeta meta = 1;
inline int InputTable::_internal_meta_size() const {
  return _internal_meta().size();
}
inline int InputTable::meta_size() const {
  return _internal_meta_size();
}
inline void InputTable::clear_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meta_.Clear();
}
inline ::hazkey::config::table::InputTable_InputTableMeta* PROTOBUF_NONNULL InputTable::mutable_meta(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.InputTable.meta)
  return _internal_mutable_meta()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableMeta>* PROTOBUF_NONNULL InputTable::mutable_meta()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hazkey.config.table.InputTable.meta)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_meta();
}
inline const ::hazkey::config::table::InputTable_InputTableMeta& InputTable::meta(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.InputTable.meta)
  return _internal_meta().Get(index);
}
inline ::hazkey::config::table::InputTable_InputTableMeta* PROTOBUF_NONNULL InputTable::add_meta()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::hazkey::config::table::InputTable_InputTableMeta* _add = _internal_mutable_meta()->Add();
  // @@protoc_insertion_point(field_add:hazkey.config.table.InputTable.meta)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableMeta>& InputTable::meta() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hazkey.config.table.InputTable.meta)
  return _internal_meta();
}
inline const ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableMeta>&
InputTable::_internal_meta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.meta_;
}
inline ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableMeta>* PROTOBUF_NONNULL
InputTable::_internal_mutable_meta() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.meta_;
}

// repeated .hazkey.config.table.InputTable.InputTableEntry input_table = 2;
inline int InputTable::_internal_input_table_size() const {
  return _internal_input_table().size();
}
inline int InputTable::input_table_size() const {
  return _internal_input_table_size();
}
inline void InputTable::clear_input_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_table_.Clear();
}
inline ::hazkey::config::table::InputTable_InputTableEntry* PROTOBUF_NONNULL InputTable::mutable_input_table(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.InputTable.input_table)
  return _internal_mutable_input_table()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableEntry>* PROTOBUF_NONNULL InputTable::mutable_input_table()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hazkey.config.table.InputTable.input_table)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_input_table();
}
inline const ::hazkey::config::table::InputTable_InputTableEntry& InputTable::input_table(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.InputTable.input_table)
  return _internal_input_table().Get(index);
}
inline ::hazkey::config::table::InputTable_InputTableEntry* PROTOBUF_NONNULL InputTable::add_input_table()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::hazkey::config::table::InputTable_InputTableEntry* _add = _internal_mutable_input_table()->Add();
  // @@protoc_insertion_point(field_add:hazkey.config.table.InputTable.input_table)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableEntry>& InputTable::input_table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hazkey.config.table.InputTable.input_table)
  return _internal_input_table();
}
inline const ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableEntry>&
InputTable::_internal_input_table() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_table_;
}
inline ::google::protobuf::RepeatedPtrField<::hazkey::config::table::InputTable_InputTableEntry>* PROTOBUF_NONNULL
InputTable::_internal_mutable_input_table() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.input_table_;
}

// -------------------------------------------------------------------

// EditOperation_Rename

// string name_old = 1;
inline void EditOperation_Rename::clear_name_old() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_old_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EditOperation_Rename::name_old() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Rename.name_old)
  return _internal_name_old();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EditOperation_Rename::set_name_old(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_old_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.EditOperation.Rename.name_old)
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Rename::mutable_name_old()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name_old();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.Rename.name_old)
  return _s;
}
inline const ::std::string& EditOperation_Rename::_internal_name_old() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_old_.Get();
}
inline void EditOperation_Rename::_internal_set_name_old(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_old_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Rename::_internal_mutable_name_old() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_old_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EditOperation_Rename::release_name_old() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.Rename.name_old)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_old_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_old_.Set("", GetArena());
  }
  return released;
}
inline void EditOperation_Rename::set_allocated_name_old(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_old_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_old_.IsDefault()) {
    _impl_.name_old_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.EditOperation.Rename.name_old)
}

// bool is_default = 2;
inline void EditOperation_Rename::clear_is_default() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool EditOperation_Rename::is_default() const {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Rename.is_default)
  return _internal_is_default();
}
inline void EditOperation_Rename::set_is_default(bool value) {
  _internal_set_is_default(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:hazkey.config.table.EditOperation.Rename.is_default)
}
inline bool EditOperation_Rename::_internal_is_default() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_default_;
}
inline void EditOperation_Rename::_internal_set_is_default(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = value;
}

// string name_new = 3;
inline void EditOperation_Rename::clear_name_new() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_new_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EditOperation_Rename::name_new() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Rename.name_new)
  return _internal_name_new();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EditOperation_Rename::set_name_new(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_new_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.EditOperation.Rename.name_new)
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Rename::mutable_name_new()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name_new();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.Rename.name_new)
  return _s;
}
inline const ::std::string& EditOperation_Rename::_internal_name_new() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_new_.Get();
}
inline void EditOperation_Rename::_internal_set_name_new(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_new_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Rename::_internal_mutable_name_new() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_new_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EditOperation_Rename::release_name_new() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.Rename.name_new)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_new_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_new_.Set("", GetArena());
  }
  return released;
}
inline void EditOperation_Rename::set_allocated_name_new(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_new_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_new_.IsDefault()) {
    _impl_.name_new_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.EditOperation.Rename.name_new)
}

// -------------------------------------------------------------------

// EditOperation_Delete

// string name = 1;
inline void EditOperation_Delete::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EditOperation_Delete::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Delete.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EditOperation_Delete::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.EditOperation.Delete.name)
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Delete::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.Delete.name)
  return _s;
}
inline const ::std::string& EditOperation_Delete::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void EditOperation_Delete::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Delete::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EditOperation_Delete::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.Delete.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void EditOperation_Delete::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.EditOperation.Delete.name)
}

// bool is_default = 2;
inline void EditOperation_Delete::clear_is_default() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool EditOperation_Delete::is_default() const {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Delete.is_default)
  return _internal_is_default();
}
inline void EditOperation_Delete::set_is_default(bool value) {
  _internal_set_is_default(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:hazkey.config.table.EditOperation.Delete.is_default)
}
inline bool EditOperation_Delete::_internal_is_default() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_default_;
}
inline void EditOperation_Delete::_internal_set_is_default(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = value;
}

// -------------------------------------------------------------------

// EditOperation_Create

// string new_name = 1;
inline void EditOperation_Create::clear_new_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EditOperation_Create::new_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Create.new_name)
  return _internal_new_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EditOperation_Create::set_new_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.EditOperation.Create.new_name)
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Create::mutable_new_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_new_name();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.Create.new_name)
  return _s;
}
inline const ::std::string& EditOperation_Create::_internal_new_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_name_.Get();
}
inline void EditOperation_Create::_internal_set_new_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Create::_internal_mutable_new_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EditOperation_Create::release_new_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.Create.new_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.new_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.new_name_.Set("", GetArena());
  }
  return released;
}
inline void EditOperation_Create::set_allocated_new_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.new_name_.IsDefault()) {
    _impl_.new_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.EditOperation.Create.new_name)
}

// -------------------------------------------------------------------

// EditOperation_Dupicate

// string source_name = 1;
inline void EditOperation_Dupicate::clear_source_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EditOperation_Dupicate::source_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Dupicate.source_name)
  return _internal_source_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EditOperation_Dupicate::set_source_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.EditOperation.Dupicate.source_name)
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Dupicate::mutable_source_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_source_name();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.Dupicate.source_name)
  return _s;
}
inline const ::std::string& EditOperation_Dupicate::_internal_source_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_name_.Get();
}
inline void EditOperation_Dupicate::_internal_set_source_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Dupicate::_internal_mutable_source_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.source_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EditOperation_Dupicate::release_source_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.Dupicate.source_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.source_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.source_name_.Set("", GetArena());
  }
  return released;
}
inline void EditOperation_Dupicate::set_allocated_source_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.source_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.source_name_.IsDefault()) {
    _impl_.source_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.EditOperation.Dupicate.source_name)
}

// bool source_is_default = 2;
inline void EditOperation_Dupicate::clear_source_is_default() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_is_default_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool EditOperation_Dupicate::source_is_default() const {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Dupicate.source_is_default)
  return _internal_source_is_default();
}
inline void EditOperation_Dupicate::set_source_is_default(bool value) {
  _internal_set_source_is_default(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:hazkey.config.table.EditOperation.Dupicate.source_is_default)
}
inline bool EditOperation_Dupicate::_internal_source_is_default() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_is_default_;
}
inline void EditOperation_Dupicate::_internal_set_source_is_default(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_is_default_ = value;
}

// string new_name = 3;
inline void EditOperation_Dupicate::clear_new_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EditOperation_Dupicate::new_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Dupicate.new_name)
  return _internal_new_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EditOperation_Dupicate::set_new_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.new_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.config.table.EditOperation.Dupicate.new_name)
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Dupicate::mutable_new_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_new_name();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.Dupicate.new_name)
  return _s;
}
inline const ::std::string& EditOperation_Dupicate::_internal_new_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_name_.Get();
}
inline void EditOperation_Dupicate::_internal_set_new_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.new_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EditOperation_Dupicate::_internal_mutable_new_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.new_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EditOperation_Dupicate::release_new_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.Dupicate.new_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.new_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.new_name_.Set("", GetArena());
  }
  return released;
}
inline void EditOperation_Dupicate::set_allocated_new_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.new_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.new_name_.IsDefault()) {
    _impl_.new_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.EditOperation.Dupicate.new_name)
}

// -------------------------------------------------------------------

// EditOperation_Update

// .hazkey.config.table.InputTable InputTable = 1;
inline bool EditOperation_Update::has_inputtable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inputtable_ != nullptr);
  return value;
}
inline void EditOperation_Update::clear_inputtable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inputtable_ != nullptr) _impl_.inputtable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hazkey::config::table::InputTable& EditOperation_Update::_internal_inputtable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::hazkey::config::table::InputTable* p = _impl_.inputtable_;
  return p != nullptr ? *p : reinterpret_cast<const ::hazkey::config::table::InputTable&>(::hazkey::config::table::_InputTable_default_instance_);
}
inline const ::hazkey::config::table::InputTable& EditOperation_Update::inputtable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.Update.InputTable)
  return _internal_inputtable();
}
inline void EditOperation_Update::unsafe_arena_set_allocated_inputtable(
    ::hazkey::config::table::InputTable* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inputtable_);
  }
  _impl_.inputtable_ = reinterpret_cast<::hazkey::config::table::InputTable*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hazkey.config.table.EditOperation.Update.InputTable)
}
inline ::hazkey::config::table::InputTable* PROTOBUF_NULLABLE EditOperation_Update::release_inputtable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hazkey::config::table::InputTable* released = _impl_.inputtable_;
  _impl_.inputtable_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::hazkey::config::table::InputTable* PROTOBUF_NULLABLE EditOperation_Update::unsafe_arena_release_inputtable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.Update.InputTable)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hazkey::config::table::InputTable* temp = _impl_.inputtable_;
  _impl_.inputtable_ = nullptr;
  return temp;
}
inline ::hazkey::config::table::InputTable* PROTOBUF_NONNULL EditOperation_Update::_internal_mutable_inputtable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inputtable_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::hazkey::config::table::InputTable>(GetArena());
    _impl_.inputtable_ = reinterpret_cast<::hazkey::config::table::InputTable*>(p);
  }
  return _impl_.inputtable_;
}
inline ::hazkey::config::table::InputTable* PROTOBUF_NONNULL EditOperation_Update::mutable_inputtable()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::hazkey::config::table::InputTable* _msg = _internal_mutable_inputtable();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.Update.InputTable)
  return _msg;
}
inline void EditOperation_Update::set_allocated_inputtable(::hazkey::config::table::InputTable* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inputtable_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.inputtable_ = reinterpret_cast<::hazkey::config::table::InputTable*>(value);
  // @@protoc_insertion_point(field_set_allocated:hazkey.config.table.EditOperation.Update.InputTable)
}

// -------------------------------------------------------------------

// EditOperation

// .hazkey.config.table.EditOperation.Rename rename = 1;
inline bool EditOperation::has_rename() const {
  return operation_case() == kRename;
}
inline bool EditOperation::_internal_has_rename() const {
  return operation_case() == kRename;
}
inline void EditOperation::set_has_rename() {
  _impl_._oneof_case_[0] = kRename;
}
inline void EditOperation::clear_rename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kRename) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.rename_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.rename_);
    }
    clear_has_operation();
  }
}
inline ::hazkey::config::table::EditOperation_Rename* PROTOBUF_NULLABLE EditOperation::release_rename() {
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.rename)
  if (operation_case() == kRename) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Rename*>(_impl_.operation_.rename_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.rename_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hazkey::config::table::EditOperation_Rename& EditOperation::_internal_rename() const {
  return operation_case() == kRename ? *reinterpret_cast<::hazkey::config::table::EditOperation_Rename*>(_impl_.operation_.rename_) : reinterpret_cast<::hazkey::config::table::EditOperation_Rename&>(::hazkey::config::table::_EditOperation_Rename_default_instance_);
}
inline const ::hazkey::config::table::EditOperation_Rename& EditOperation::rename() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.rename)
  return _internal_rename();
}
inline ::hazkey::config::table::EditOperation_Rename* PROTOBUF_NULLABLE EditOperation::unsafe_arena_release_rename() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hazkey.config.table.EditOperation.rename)
  if (operation_case() == kRename) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Rename*>(_impl_.operation_.rename_);
    _impl_.operation_.rename_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditOperation::unsafe_arena_set_allocated_rename(
    ::hazkey::config::table::EditOperation_Rename* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_rename();
    _impl_.operation_.rename_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hazkey.config.table.EditOperation.rename)
}
inline ::hazkey::config::table::EditOperation_Rename* PROTOBUF_NONNULL EditOperation::_internal_mutable_rename() {
  if (operation_case() != kRename) {
    clear_operation();
    set_has_rename();
    _impl_.operation_.rename_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::hazkey::config::table::EditOperation_Rename>(GetArena()));
  }
  return reinterpret_cast<::hazkey::config::table::EditOperation_Rename*>(_impl_.operation_.rename_);
}
inline ::hazkey::config::table::EditOperation_Rename* PROTOBUF_NONNULL EditOperation::mutable_rename()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hazkey::config::table::EditOperation_Rename* _msg = _internal_mutable_rename();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.rename)
  return _msg;
}

// .hazkey.config.table.EditOperation.Delete delete = 2;
inline bool EditOperation::has_delete_() const {
  return operation_case() == kDelete;
}
inline bool EditOperation::_internal_has_delete_() const {
  return operation_case() == kDelete;
}
inline void EditOperation::set_has_delete_() {
  _impl_._oneof_case_[0] = kDelete;
}
inline void EditOperation::clear_delete_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kDelete) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.delete__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.delete__);
    }
    clear_has_operation();
  }
}
inline ::hazkey::config::table::EditOperation_Delete* PROTOBUF_NULLABLE EditOperation::release_delete_() {
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.delete)
  if (operation_case() == kDelete) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Delete*>(_impl_.operation_.delete__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.delete__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hazkey::config::table::EditOperation_Delete& EditOperation::_internal_delete_() const {
  return operation_case() == kDelete ? *reinterpret_cast<::hazkey::config::table::EditOperation_Delete*>(_impl_.operation_.delete__) : reinterpret_cast<::hazkey::config::table::EditOperation_Delete&>(::hazkey::config::table::_EditOperation_Delete_default_instance_);
}
inline const ::hazkey::config::table::EditOperation_Delete& EditOperation::delete_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.delete)
  return _internal_delete_();
}
inline ::hazkey::config::table::EditOperation_Delete* PROTOBUF_NULLABLE EditOperation::unsafe_arena_release_delete_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hazkey.config.table.EditOperation.delete)
  if (operation_case() == kDelete) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Delete*>(_impl_.operation_.delete__);
    _impl_.operation_.delete__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditOperation::unsafe_arena_set_allocated_delete_(
    ::hazkey::config::table::EditOperation_Delete* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_delete_();
    _impl_.operation_.delete__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hazkey.config.table.EditOperation.delete)
}
inline ::hazkey::config::table::EditOperation_Delete* PROTOBUF_NONNULL EditOperation::_internal_mutable_delete_() {
  if (operation_case() != kDelete) {
    clear_operation();
    set_has_delete_();
    _impl_.operation_.delete__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::hazkey::config::table::EditOperation_Delete>(GetArena()));
  }
  return reinterpret_cast<::hazkey::config::table::EditOperation_Delete*>(_impl_.operation_.delete__);
}
inline ::hazkey::config::table::EditOperation_Delete* PROTOBUF_NONNULL EditOperation::mutable_delete_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hazkey::config::table::EditOperation_Delete* _msg = _internal_mutable_delete_();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.delete)
  return _msg;
}

// .hazkey.config.table.EditOperation.Create create = 3;
inline bool EditOperation::has_create() const {
  return operation_case() == kCreate;
}
inline bool EditOperation::_internal_has_create() const {
  return operation_case() == kCreate;
}
inline void EditOperation::set_has_create() {
  _impl_._oneof_case_[0] = kCreate;
}
inline void EditOperation::clear_create() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kCreate) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.create_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.create_);
    }
    clear_has_operation();
  }
}
inline ::hazkey::config::table::EditOperation_Create* PROTOBUF_NULLABLE EditOperation::release_create() {
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.create)
  if (operation_case() == kCreate) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Create*>(_impl_.operation_.create_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hazkey::config::table::EditOperation_Create& EditOperation::_internal_create() const {
  return operation_case() == kCreate ? *reinterpret_cast<::hazkey::config::table::EditOperation_Create*>(_impl_.operation_.create_) : reinterpret_cast<::hazkey::config::table::EditOperation_Create&>(::hazkey::config::table::_EditOperation_Create_default_instance_);
}
inline const ::hazkey::config::table::EditOperation_Create& EditOperation::create() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.create)
  return _internal_create();
}
inline ::hazkey::config::table::EditOperation_Create* PROTOBUF_NULLABLE EditOperation::unsafe_arena_release_create() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hazkey.config.table.EditOperation.create)
  if (operation_case() == kCreate) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Create*>(_impl_.operation_.create_);
    _impl_.operation_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditOperation::unsafe_arena_set_allocated_create(
    ::hazkey::config::table::EditOperation_Create* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_create();
    _impl_.operation_.create_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hazkey.config.table.EditOperation.create)
}
inline ::hazkey::config::table::EditOperation_Create* PROTOBUF_NONNULL EditOperation::_internal_mutable_create() {
  if (operation_case() != kCreate) {
    clear_operation();
    set_has_create();
    _impl_.operation_.create_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::hazkey::config::table::EditOperation_Create>(GetArena()));
  }
  return reinterpret_cast<::hazkey::config::table::EditOperation_Create*>(_impl_.operation_.create_);
}
inline ::hazkey::config::table::EditOperation_Create* PROTOBUF_NONNULL EditOperation::mutable_create()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hazkey::config::table::EditOperation_Create* _msg = _internal_mutable_create();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.create)
  return _msg;
}

// .hazkey.config.table.EditOperation.Dupicate dupicate = 4;
inline bool EditOperation::has_dupicate() const {
  return operation_case() == kDupicate;
}
inline bool EditOperation::_internal_has_dupicate() const {
  return operation_case() == kDupicate;
}
inline void EditOperation::set_has_dupicate() {
  _impl_._oneof_case_[0] = kDupicate;
}
inline void EditOperation::clear_dupicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kDupicate) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.dupicate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.dupicate_);
    }
    clear_has_operation();
  }
}
inline ::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NULLABLE EditOperation::release_dupicate() {
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.dupicate)
  if (operation_case() == kDupicate) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Dupicate*>(_impl_.operation_.dupicate_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.dupicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hazkey::config::table::EditOperation_Dupicate& EditOperation::_internal_dupicate() const {
  return operation_case() == kDupicate ? *reinterpret_cast<::hazkey::config::table::EditOperation_Dupicate*>(_impl_.operation_.dupicate_) : reinterpret_cast<::hazkey::config::table::EditOperation_Dupicate&>(::hazkey::config::table::_EditOperation_Dupicate_default_instance_);
}
inline const ::hazkey::config::table::EditOperation_Dupicate& EditOperation::dupicate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.dupicate)
  return _internal_dupicate();
}
inline ::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NULLABLE EditOperation::unsafe_arena_release_dupicate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hazkey.config.table.EditOperation.dupicate)
  if (operation_case() == kDupicate) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Dupicate*>(_impl_.operation_.dupicate_);
    _impl_.operation_.dupicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditOperation::unsafe_arena_set_allocated_dupicate(
    ::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_dupicate();
    _impl_.operation_.dupicate_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hazkey.config.table.EditOperation.dupicate)
}
inline ::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NONNULL EditOperation::_internal_mutable_dupicate() {
  if (operation_case() != kDupicate) {
    clear_operation();
    set_has_dupicate();
    _impl_.operation_.dupicate_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::hazkey::config::table::EditOperation_Dupicate>(GetArena()));
  }
  return reinterpret_cast<::hazkey::config::table::EditOperation_Dupicate*>(_impl_.operation_.dupicate_);
}
inline ::hazkey::config::table::EditOperation_Dupicate* PROTOBUF_NONNULL EditOperation::mutable_dupicate()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hazkey::config::table::EditOperation_Dupicate* _msg = _internal_mutable_dupicate();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.dupicate)
  return _msg;
}

// .hazkey.config.table.EditOperation.Update update = 5;
inline bool EditOperation::has_update() const {
  return operation_case() == kUpdate;
}
inline bool EditOperation::_internal_has_update() const {
  return operation_case() == kUpdate;
}
inline void EditOperation::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void EditOperation::clear_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.update_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.update_);
    }
    clear_has_operation();
  }
}
inline ::hazkey::config::table::EditOperation_Update* PROTOBUF_NULLABLE EditOperation::release_update() {
  // @@protoc_insertion_point(field_release:hazkey.config.table.EditOperation.update)
  if (operation_case() == kUpdate) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Update*>(_impl_.operation_.update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hazkey::config::table::EditOperation_Update& EditOperation::_internal_update() const {
  return operation_case() == kUpdate ? *reinterpret_cast<::hazkey::config::table::EditOperation_Update*>(_impl_.operation_.update_) : reinterpret_cast<::hazkey::config::table::EditOperation_Update&>(::hazkey::config::table::_EditOperation_Update_default_instance_);
}
inline const ::hazkey::config::table::EditOperation_Update& EditOperation::update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.config.table.EditOperation.update)
  return _internal_update();
}
inline ::hazkey::config::table::EditOperation_Update* PROTOBUF_NULLABLE EditOperation::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hazkey.config.table.EditOperation.update)
  if (operation_case() == kUpdate) {
    clear_has_operation();
    auto* temp = reinterpret_cast<::hazkey::config::table::EditOperation_Update*>(_impl_.operation_.update_);
    _impl_.operation_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditOperation::unsafe_arena_set_allocated_update(
    ::hazkey::config::table::EditOperation_Update* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_update();
    _impl_.operation_.update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hazkey.config.table.EditOperation.update)
}
inline ::hazkey::config::table::EditOperation_Update* PROTOBUF_NONNULL EditOperation::_internal_mutable_update() {
  if (operation_case() != kUpdate) {
    clear_operation();
    set_has_update();
    _impl_.operation_.update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::hazkey::config::table::EditOperation_Update>(GetArena()));
  }
  return reinterpret_cast<::hazkey::config::table::EditOperation_Update*>(_impl_.operation_.update_);
}
inline ::hazkey::config::table::EditOperation_Update* PROTOBUF_NONNULL EditOperation::mutable_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hazkey::config::table::EditOperation_Update* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:hazkey.config.table.EditOperation.update)
  return _msg;
}

inline bool EditOperation::has_operation() const {
  return operation_case() != OPERATION_NOT_SET;
}
inline void EditOperation::clear_has_operation() {
  _impl_._oneof_case_[0] = OPERATION_NOT_SET;
}
inline EditOperation::OperationCase EditOperation::operation_case() const {
  return EditOperation::OperationCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace table
}  // namespace config
}  // namespace hazkey


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // table_2eproto_2epb_2eh
