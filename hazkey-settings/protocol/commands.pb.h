// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: commands.proto
// Protobuf C++ Version: 6.31.1

#ifndef commands_2eproto_2epb_2eh
#define commands_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_commands_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_commands_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_commands_2eproto;
}  // extern "C"
namespace hazkey {
namespace commands {
enum GetComposingString_CharType : int;
extern const uint32_t GetComposingString_CharType_internal_data_[];
class CandidatesResult;
struct CandidatesResultDefaultTypeInternal;
extern CandidatesResultDefaultTypeInternal _CandidatesResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CandidatesResult_class_data_;
class CandidatesResult_Candidate;
struct CandidatesResult_CandidateDefaultTypeInternal;
extern CandidatesResult_CandidateDefaultTypeInternal _CandidatesResult_Candidate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CandidatesResult_Candidate_class_data_;
class DeleteLeft;
struct DeleteLeftDefaultTypeInternal;
extern DeleteLeftDefaultTypeInternal _DeleteLeft_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteLeft_class_data_;
class DeleteRight;
struct DeleteRightDefaultTypeInternal;
extern DeleteRightDefaultTypeInternal _DeleteRight_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteRight_class_data_;
class GetCandidates;
struct GetCandidatesDefaultTypeInternal;
extern GetCandidatesDefaultTypeInternal _GetCandidates_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCandidates_class_data_;
class GetComposingString;
struct GetComposingStringDefaultTypeInternal;
extern GetComposingStringDefaultTypeInternal _GetComposingString_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetComposingString_class_data_;
class GetHiraganaWithCursor;
struct GetHiraganaWithCursorDefaultTypeInternal;
extern GetHiraganaWithCursorDefaultTypeInternal _GetHiraganaWithCursor_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetHiraganaWithCursor_class_data_;
class InputChar;
struct InputCharDefaultTypeInternal;
extern InputCharDefaultTypeInternal _InputChar_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InputChar_class_data_;
class MoveCursor;
struct MoveCursorDefaultTypeInternal;
extern MoveCursorDefaultTypeInternal _MoveCursor_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MoveCursor_class_data_;
class NewComposingText;
struct NewComposingTextDefaultTypeInternal;
extern NewComposingTextDefaultTypeInternal _NewComposingText_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NewComposingText_class_data_;
class PrefixComplete;
struct PrefixCompleteDefaultTypeInternal;
extern PrefixCompleteDefaultTypeInternal _PrefixComplete_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PrefixComplete_class_data_;
class SetContext;
struct SetContextDefaultTypeInternal;
extern SetContextDefaultTypeInternal _SetContext_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetContext_class_data_;
class Text;
struct TextDefaultTypeInternal;
extern TextDefaultTypeInternal _Text_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Text_class_data_;
class TextWithCursor;
struct TextWithCursorDefaultTypeInternal;
extern TextWithCursorDefaultTypeInternal _TextWithCursor_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TextWithCursor_class_data_;
}  // namespace commands
}  // namespace hazkey
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::hazkey::commands::GetComposingString_CharType_internal_data_>
    internal::EnumTraitsImpl::value<::hazkey::commands::GetComposingString_CharType>;
}  // namespace protobuf
}  // namespace google

namespace hazkey {
namespace commands {
enum GetComposingString_CharType : int {
  GetComposingString_CharType_HIRAGANA = 0,
  GetComposingString_CharType_KATAKANA_FULL = 1,
  GetComposingString_CharType_KATAKANA_HALF = 2,
  GetComposingString_CharType_ALPHABET_FULL = 3,
  GetComposingString_CharType_ALPHABET_HALF = 4,
  GetComposingString_CharType_GetComposingString_CharType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GetComposingString_CharType_GetComposingString_CharType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GetComposingString_CharType_internal_data_[];
inline constexpr GetComposingString_CharType GetComposingString_CharType_CharType_MIN =
    static_cast<GetComposingString_CharType>(0);
inline constexpr GetComposingString_CharType GetComposingString_CharType_CharType_MAX =
    static_cast<GetComposingString_CharType>(4);
inline bool GetComposingString_CharType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int GetComposingString_CharType_CharType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GetComposingString_CharType_descriptor();
template <typename T>
const ::std::string& GetComposingString_CharType_Name(T value) {
  static_assert(::std::is_same<T, GetComposingString_CharType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CharType_Name().");
  return GetComposingString_CharType_Name(static_cast<GetComposingString_CharType>(value));
}
template <>
inline const ::std::string& GetComposingString_CharType_Name(GetComposingString_CharType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GetComposingString_CharType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool GetComposingString_CharType_Parse(
    ::absl::string_view name, GetComposingString_CharType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetComposingString_CharType>(GetComposingString_CharType_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class TextWithCursor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.TextWithCursor) */ {
 public:
  inline TextWithCursor() : TextWithCursor(nullptr) {}
  ~TextWithCursor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TextWithCursor* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TextWithCursor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TextWithCursor(::google::protobuf::internal::ConstantInitialized);

  inline TextWithCursor(const TextWithCursor& from) : TextWithCursor(nullptr, from) {}
  inline TextWithCursor(TextWithCursor&& from) noexcept
      : TextWithCursor(nullptr, ::std::move(from)) {}
  inline TextWithCursor& operator=(const TextWithCursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextWithCursor& operator=(TextWithCursor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextWithCursor& default_instance() {
    return *reinterpret_cast<const TextWithCursor*>(
        &_TextWithCursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(TextWithCursor& a, TextWithCursor& b) { a.Swap(&b); }
  inline void Swap(TextWithCursor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextWithCursor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextWithCursor* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TextWithCursor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TextWithCursor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TextWithCursor& from) { TextWithCursor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TextWithCursor* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.TextWithCursor"; }

 protected:
  explicit TextWithCursor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TextWithCursor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TextWithCursor& from);
  TextWithCursor(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TextWithCursor&& from) noexcept
      : TextWithCursor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeforeCursosrFieldNumber = 1,
    kOnCursorFieldNumber = 2,
    kAfterCursorFieldNumber = 3,
  };
  // string beforeCursosr = 1;
  void clear_beforecursosr() ;
  const ::std::string& beforecursosr() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_beforecursosr(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_beforecursosr();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_beforecursosr();
  void set_allocated_beforecursosr(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_beforecursosr() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_beforecursosr(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_beforecursosr();

  public:
  // string onCursor = 2;
  void clear_oncursor() ;
  const ::std::string& oncursor() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_oncursor(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_oncursor();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_oncursor();
  void set_allocated_oncursor(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_oncursor() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_oncursor(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_oncursor();

  public:
  // string afterCursor = 3;
  void clear_aftercursor() ;
  const ::std::string& aftercursor() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_aftercursor(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_aftercursor();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_aftercursor();
  void set_allocated_aftercursor(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_aftercursor() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_aftercursor(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_aftercursor();

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.TextWithCursor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 71,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TextWithCursor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr beforecursosr_;
    ::google::protobuf::internal::ArenaStringPtr oncursor_;
    ::google::protobuf::internal::ArenaStringPtr aftercursor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TextWithCursor_class_data_;
// -------------------------------------------------------------------

class Text final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.Text) */ {
 public:
  inline Text() : Text(nullptr) {}
  ~Text() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Text* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Text));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Text(::google::protobuf::internal::ConstantInitialized);

  inline Text(const Text& from) : Text(nullptr, from) {}
  inline Text(Text&& from) noexcept
      : Text(nullptr, ::std::move(from)) {}
  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }
  inline Text& operator=(Text&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Text& default_instance() {
    return *reinterpret_cast<const Text*>(
        &_Text_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Text& a, Text& b) { a.Swap(&b); }
  inline void Swap(Text* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Text* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Text* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Text>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Text& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Text& from) { Text::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Text* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.Text"; }

 protected:
  explicit Text(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Text(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Text& from);
  Text(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Text&& from) noexcept
      : Text(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text() ;
  const ::std::string& text() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_text();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_text();
  void set_allocated_text(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_text() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_text(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.Text)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 33,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Text& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Text_class_data_;
// -------------------------------------------------------------------

class SetContext final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.SetContext) */ {
 public:
  inline SetContext() : SetContext(nullptr) {}
  ~SetContext() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetContext* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetContext));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetContext(::google::protobuf::internal::ConstantInitialized);

  inline SetContext(const SetContext& from) : SetContext(nullptr, from) {}
  inline SetContext(SetContext&& from) noexcept
      : SetContext(nullptr, ::std::move(from)) {}
  inline SetContext& operator=(const SetContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetContext& operator=(SetContext&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetContext& default_instance() {
    return *reinterpret_cast<const SetContext*>(
        &_SetContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SetContext& a, SetContext& b) { a.Swap(&b); }
  inline void Swap(SetContext* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetContext* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetContext* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetContext>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetContext& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetContext& from) { SetContext::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetContext* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.SetContext"; }

 protected:
  explicit SetContext(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SetContext(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SetContext& from);
  SetContext(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SetContext&& from) noexcept
      : SetContext(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kContextFieldNumber = 1,
    kAnchorFieldNumber = 2,
  };
  // string context = 1;
  void clear_context() ;
  const ::std::string& context() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_context(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_context();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_context();
  void set_allocated_context(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_context() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_context(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_context();

  public:
  // int32 anchor = 2;
  void clear_anchor() ;
  ::int32_t anchor() const;
  void set_anchor(::int32_t value);

  private:
  ::int32_t _internal_anchor() const;
  void _internal_set_anchor(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.SetContext)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 42,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SetContext& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr context_;
    ::int32_t anchor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SetContext_class_data_;
// -------------------------------------------------------------------

class PrefixComplete final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.PrefixComplete) */ {
 public:
  inline PrefixComplete() : PrefixComplete(nullptr) {}
  ~PrefixComplete() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PrefixComplete* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PrefixComplete));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrefixComplete(::google::protobuf::internal::ConstantInitialized);

  inline PrefixComplete(const PrefixComplete& from) : PrefixComplete(nullptr, from) {}
  inline PrefixComplete(PrefixComplete&& from) noexcept
      : PrefixComplete(nullptr, ::std::move(from)) {}
  inline PrefixComplete& operator=(const PrefixComplete& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrefixComplete& operator=(PrefixComplete&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrefixComplete& default_instance() {
    return *reinterpret_cast<const PrefixComplete*>(
        &_PrefixComplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(PrefixComplete& a, PrefixComplete& b) { a.Swap(&b); }
  inline void Swap(PrefixComplete* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrefixComplete* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrefixComplete* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PrefixComplete>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrefixComplete& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrefixComplete& from) { PrefixComplete::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PrefixComplete* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.PrefixComplete"; }

 protected:
  explicit PrefixComplete(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PrefixComplete(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PrefixComplete& from);
  PrefixComplete(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PrefixComplete&& from) noexcept
      : PrefixComplete(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.PrefixComplete)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PrefixComplete& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PrefixComplete_class_data_;
// -------------------------------------------------------------------

class NewComposingText final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:hazkey.commands.NewComposingText) */ {
 public:
  inline NewComposingText() : NewComposingText(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NewComposingText* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NewComposingText));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NewComposingText(::google::protobuf::internal::ConstantInitialized);

  inline NewComposingText(const NewComposingText& from) : NewComposingText(nullptr, from) {}
  inline NewComposingText(NewComposingText&& from) noexcept
      : NewComposingText(nullptr, ::std::move(from)) {}
  inline NewComposingText& operator=(const NewComposingText& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewComposingText& operator=(NewComposingText&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewComposingText& default_instance() {
    return *reinterpret_cast<const NewComposingText*>(
        &_NewComposingText_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NewComposingText& a, NewComposingText& b) { a.Swap(&b); }
  inline void Swap(NewComposingText* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewComposingText* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewComposingText* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<NewComposingText>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NewComposingText& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NewComposingText& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.NewComposingText"; }

 protected:
  explicit NewComposingText(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NewComposingText(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NewComposingText& from);
  NewComposingText(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NewComposingText&& from) noexcept
      : NewComposingText(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:hazkey.commands.NewComposingText)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NewComposingText& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NewComposingText_class_data_;
// -------------------------------------------------------------------

class MoveCursor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.MoveCursor) */ {
 public:
  inline MoveCursor() : MoveCursor(nullptr) {}
  ~MoveCursor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveCursor* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveCursor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveCursor(::google::protobuf::internal::ConstantInitialized);

  inline MoveCursor(const MoveCursor& from) : MoveCursor(nullptr, from) {}
  inline MoveCursor(MoveCursor&& from) noexcept
      : MoveCursor(nullptr, ::std::move(from)) {}
  inline MoveCursor& operator=(const MoveCursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveCursor& operator=(MoveCursor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveCursor& default_instance() {
    return *reinterpret_cast<const MoveCursor*>(
        &_MoveCursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(MoveCursor& a, MoveCursor& b) { a.Swap(&b); }
  inline void Swap(MoveCursor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveCursor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveCursor* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveCursor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveCursor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveCursor& from) { MoveCursor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveCursor* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.MoveCursor"; }

 protected:
  explicit MoveCursor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MoveCursor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MoveCursor& from);
  MoveCursor(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MoveCursor&& from) noexcept
      : MoveCursor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetFieldNumber = 1,
  };
  // int32 offset = 1;
  void clear_offset() ;
  ::int32_t offset() const;
  void set_offset(::int32_t value);

  private:
  ::int32_t _internal_offset() const;
  void _internal_set_offset(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.MoveCursor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MoveCursor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MoveCursor_class_data_;
// -------------------------------------------------------------------

class InputChar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.InputChar) */ {
 public:
  inline InputChar() : InputChar(nullptr) {}
  ~InputChar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InputChar* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InputChar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputChar(::google::protobuf::internal::ConstantInitialized);

  inline InputChar(const InputChar& from) : InputChar(nullptr, from) {}
  inline InputChar(InputChar&& from) noexcept
      : InputChar(nullptr, ::std::move(from)) {}
  inline InputChar& operator=(const InputChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputChar& operator=(InputChar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputChar& default_instance() {
    return *reinterpret_cast<const InputChar*>(
        &_InputChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(InputChar& a, InputChar& b) { a.Swap(&b); }
  inline void Swap(InputChar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputChar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputChar* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InputChar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputChar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputChar& from) { InputChar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InputChar* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.InputChar"; }

 protected:
  explicit InputChar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InputChar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InputChar& from);
  InputChar(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InputChar&& from) noexcept
      : InputChar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 1,
    kIsDirectFieldNumber = 2,
  };
  // string text = 1;
  void clear_text() ;
  const ::std::string& text() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_text();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_text();
  void set_allocated_text(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_text() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_text(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_text();

  public:
  // bool is_direct = 2;
  void clear_is_direct() ;
  bool is_direct() const;
  void set_is_direct(bool value);

  private:
  bool _internal_is_direct() const;
  void _internal_set_is_direct(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.InputChar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 38,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InputChar& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    bool is_direct_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InputChar_class_data_;
// -------------------------------------------------------------------

class GetHiraganaWithCursor final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:hazkey.commands.GetHiraganaWithCursor) */ {
 public:
  inline GetHiraganaWithCursor() : GetHiraganaWithCursor(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetHiraganaWithCursor* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetHiraganaWithCursor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetHiraganaWithCursor(::google::protobuf::internal::ConstantInitialized);

  inline GetHiraganaWithCursor(const GetHiraganaWithCursor& from) : GetHiraganaWithCursor(nullptr, from) {}
  inline GetHiraganaWithCursor(GetHiraganaWithCursor&& from) noexcept
      : GetHiraganaWithCursor(nullptr, ::std::move(from)) {}
  inline GetHiraganaWithCursor& operator=(const GetHiraganaWithCursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHiraganaWithCursor& operator=(GetHiraganaWithCursor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHiraganaWithCursor& default_instance() {
    return *reinterpret_cast<const GetHiraganaWithCursor*>(
        &_GetHiraganaWithCursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GetHiraganaWithCursor& a, GetHiraganaWithCursor& b) { a.Swap(&b); }
  inline void Swap(GetHiraganaWithCursor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHiraganaWithCursor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHiraganaWithCursor* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetHiraganaWithCursor>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetHiraganaWithCursor& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetHiraganaWithCursor& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.GetHiraganaWithCursor"; }

 protected:
  explicit GetHiraganaWithCursor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetHiraganaWithCursor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetHiraganaWithCursor& from);
  GetHiraganaWithCursor(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetHiraganaWithCursor&& from) noexcept
      : GetHiraganaWithCursor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:hazkey.commands.GetHiraganaWithCursor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetHiraganaWithCursor& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetHiraganaWithCursor_class_data_;
// -------------------------------------------------------------------

class GetComposingString final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.GetComposingString) */ {
 public:
  inline GetComposingString() : GetComposingString(nullptr) {}
  ~GetComposingString() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetComposingString* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetComposingString));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetComposingString(::google::protobuf::internal::ConstantInitialized);

  inline GetComposingString(const GetComposingString& from) : GetComposingString(nullptr, from) {}
  inline GetComposingString(GetComposingString&& from) noexcept
      : GetComposingString(nullptr, ::std::move(from)) {}
  inline GetComposingString& operator=(const GetComposingString& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetComposingString& operator=(GetComposingString&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetComposingString& default_instance() {
    return *reinterpret_cast<const GetComposingString*>(
        &_GetComposingString_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(GetComposingString& a, GetComposingString& b) { a.Swap(&b); }
  inline void Swap(GetComposingString* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetComposingString* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetComposingString* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetComposingString>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetComposingString& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetComposingString& from) { GetComposingString::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetComposingString* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.GetComposingString"; }

 protected:
  explicit GetComposingString(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetComposingString(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetComposingString& from);
  GetComposingString(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetComposingString&& from) noexcept
      : GetComposingString(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using CharType = GetComposingString_CharType;
  static constexpr CharType HIRAGANA = GetComposingString_CharType_HIRAGANA;
  static constexpr CharType KATAKANA_FULL = GetComposingString_CharType_KATAKANA_FULL;
  static constexpr CharType KATAKANA_HALF = GetComposingString_CharType_KATAKANA_HALF;
  static constexpr CharType ALPHABET_FULL = GetComposingString_CharType_ALPHABET_FULL;
  static constexpr CharType ALPHABET_HALF = GetComposingString_CharType_ALPHABET_HALF;
  static inline bool CharType_IsValid(int value) {
    return GetComposingString_CharType_IsValid(value);
  }
  static constexpr CharType CharType_MIN = GetComposingString_CharType_CharType_MIN;
  static constexpr CharType CharType_MAX = GetComposingString_CharType_CharType_MAX;
  static constexpr int CharType_ARRAYSIZE = GetComposingString_CharType_CharType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CharType_descriptor() {
    return GetComposingString_CharType_descriptor();
  }
  template <typename T>
  static inline const ::std::string& CharType_Name(T value) {
    return GetComposingString_CharType_Name(value);
  }
  static inline bool CharType_Parse(
      ::absl::string_view name, CharType* PROTOBUF_NONNULL value) {
    return GetComposingString_CharType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kCurrentPreeditFieldNumber = 2,
    kCharTypeFieldNumber = 1,
  };
  // string current_preedit = 2;
  void clear_current_preedit() ;
  const ::std::string& current_preedit() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_current_preedit(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_current_preedit();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_current_preedit();
  void set_allocated_current_preedit(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_current_preedit() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_current_preedit(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_current_preedit();

  public:
  // .hazkey.commands.GetComposingString.CharType char_type = 1;
  void clear_char_type() ;
  ::hazkey::commands::GetComposingString_CharType char_type() const;
  void set_char_type(::hazkey::commands::GetComposingString_CharType value);

  private:
  ::hazkey::commands::GetComposingString_CharType _internal_char_type() const;
  void _internal_set_char_type(::hazkey::commands::GetComposingString_CharType value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.GetComposingString)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetComposingString& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr current_preedit_;
    int char_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetComposingString_class_data_;
// -------------------------------------------------------------------

class GetCandidates final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.GetCandidates) */ {
 public:
  inline GetCandidates() : GetCandidates(nullptr) {}
  ~GetCandidates() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCandidates* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCandidates));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCandidates(::google::protobuf::internal::ConstantInitialized);

  inline GetCandidates(const GetCandidates& from) : GetCandidates(nullptr, from) {}
  inline GetCandidates(GetCandidates&& from) noexcept
      : GetCandidates(nullptr, ::std::move(from)) {}
  inline GetCandidates& operator=(const GetCandidates& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCandidates& operator=(GetCandidates&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCandidates& default_instance() {
    return *reinterpret_cast<const GetCandidates*>(
        &_GetCandidates_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GetCandidates& a, GetCandidates& b) { a.Swap(&b); }
  inline void Swap(GetCandidates* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCandidates* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCandidates* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCandidates>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCandidates& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCandidates& from) { GetCandidates::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCandidates* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.GetCandidates"; }

 protected:
  explicit GetCandidates(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCandidates(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCandidates& from);
  GetCandidates(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCandidates&& from) noexcept
      : GetCandidates(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIsSuggestFieldNumber = 1,
  };
  // bool is_suggest = 1;
  void clear_is_suggest() ;
  bool is_suggest() const;
  void set_is_suggest(bool value);

  private:
  bool _internal_is_suggest() const;
  void _internal_set_is_suggest(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.GetCandidates)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCandidates& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool is_suggest_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCandidates_class_data_;
// -------------------------------------------------------------------

class DeleteRight final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:hazkey.commands.DeleteRight) */ {
 public:
  inline DeleteRight() : DeleteRight(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteRight* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteRight));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteRight(::google::protobuf::internal::ConstantInitialized);

  inline DeleteRight(const DeleteRight& from) : DeleteRight(nullptr, from) {}
  inline DeleteRight(DeleteRight&& from) noexcept
      : DeleteRight(nullptr, ::std::move(from)) {}
  inline DeleteRight& operator=(const DeleteRight& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRight& operator=(DeleteRight&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRight& default_instance() {
    return *reinterpret_cast<const DeleteRight*>(
        &_DeleteRight_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(DeleteRight& a, DeleteRight& b) { a.Swap(&b); }
  inline void Swap(DeleteRight* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRight* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRight* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeleteRight>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRight& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRight& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.DeleteRight"; }

 protected:
  explicit DeleteRight(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteRight(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteRight& from);
  DeleteRight(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteRight&& from) noexcept
      : DeleteRight(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:hazkey.commands.DeleteRight)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteRight& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteRight_class_data_;
// -------------------------------------------------------------------

class DeleteLeft final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:hazkey.commands.DeleteLeft) */ {
 public:
  inline DeleteLeft() : DeleteLeft(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteLeft* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteLeft));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteLeft(::google::protobuf::internal::ConstantInitialized);

  inline DeleteLeft(const DeleteLeft& from) : DeleteLeft(nullptr, from) {}
  inline DeleteLeft(DeleteLeft&& from) noexcept
      : DeleteLeft(nullptr, ::std::move(from)) {}
  inline DeleteLeft& operator=(const DeleteLeft& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLeft& operator=(DeleteLeft&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLeft& default_instance() {
    return *reinterpret_cast<const DeleteLeft*>(
        &_DeleteLeft_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(DeleteLeft& a, DeleteLeft& b) { a.Swap(&b); }
  inline void Swap(DeleteLeft* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLeft* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLeft* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeleteLeft>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteLeft& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteLeft& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.DeleteLeft"; }

 protected:
  explicit DeleteLeft(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteLeft(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteLeft& from);
  DeleteLeft(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteLeft&& from) noexcept
      : DeleteLeft(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:hazkey.commands.DeleteLeft)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteLeft& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteLeft_class_data_;
// -------------------------------------------------------------------

class CandidatesResult_Candidate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.CandidatesResult.Candidate) */ {
 public:
  inline CandidatesResult_Candidate() : CandidatesResult_Candidate(nullptr) {}
  ~CandidatesResult_Candidate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CandidatesResult_Candidate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CandidatesResult_Candidate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CandidatesResult_Candidate(::google::protobuf::internal::ConstantInitialized);

  inline CandidatesResult_Candidate(const CandidatesResult_Candidate& from) : CandidatesResult_Candidate(nullptr, from) {}
  inline CandidatesResult_Candidate(CandidatesResult_Candidate&& from) noexcept
      : CandidatesResult_Candidate(nullptr, ::std::move(from)) {}
  inline CandidatesResult_Candidate& operator=(const CandidatesResult_Candidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CandidatesResult_Candidate& operator=(CandidatesResult_Candidate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CandidatesResult_Candidate& default_instance() {
    return *reinterpret_cast<const CandidatesResult_Candidate*>(
        &_CandidatesResult_Candidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(CandidatesResult_Candidate& a, CandidatesResult_Candidate& b) { a.Swap(&b); }
  inline void Swap(CandidatesResult_Candidate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CandidatesResult_Candidate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CandidatesResult_Candidate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CandidatesResult_Candidate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CandidatesResult_Candidate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CandidatesResult_Candidate& from) { CandidatesResult_Candidate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CandidatesResult_Candidate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.CandidatesResult.Candidate"; }

 protected:
  explicit CandidatesResult_Candidate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CandidatesResult_Candidate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CandidatesResult_Candidate& from);
  CandidatesResult_Candidate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CandidatesResult_Candidate&& from) noexcept
      : CandidatesResult_Candidate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWordsFieldNumber = 3,
    kDiffIndexesFieldNumber = 4,
    kTextFieldNumber = 1,
    kSubHiraganaFieldNumber = 2,
  };
  // repeated string words = 3;
  int words_size() const;
  private:
  int _internal_words_size() const;

  public:
  void clear_words() ;
  const ::std::string& words(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_words(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_words(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_words();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_words(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& words() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_words();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_words() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_words();

  public:
  // repeated int32 diff_indexes = 4;
  int diff_indexes_size() const;
  private:
  int _internal_diff_indexes_size() const;

  public:
  void clear_diff_indexes() ;
  ::int32_t diff_indexes(int index) const;
  void set_diff_indexes(int index, ::int32_t value);
  void add_diff_indexes(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& diff_indexes() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_diff_indexes();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_diff_indexes() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_diff_indexes();

  public:
  // string text = 1;
  void clear_text() ;
  const ::std::string& text() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_text();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_text();
  void set_allocated_text(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_text() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_text(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_text();

  public:
  // string sub_hiragana = 2;
  void clear_sub_hiragana() ;
  const ::std::string& sub_hiragana() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_sub_hiragana(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_sub_hiragana();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_sub_hiragana();
  void set_allocated_sub_hiragana(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_sub_hiragana() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sub_hiragana(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_sub_hiragana();

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.CandidatesResult.Candidate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 72,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CandidatesResult_Candidate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> words_;
    ::google::protobuf::RepeatedField<::int32_t> diff_indexes_;
    ::google::protobuf::internal::CachedSize _diff_indexes_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr sub_hiragana_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CandidatesResult_Candidate_class_data_;
// -------------------------------------------------------------------

class CandidatesResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hazkey.commands.CandidatesResult) */ {
 public:
  inline CandidatesResult() : CandidatesResult(nullptr) {}
  ~CandidatesResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CandidatesResult* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CandidatesResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CandidatesResult(::google::protobuf::internal::ConstantInitialized);

  inline CandidatesResult(const CandidatesResult& from) : CandidatesResult(nullptr, from) {}
  inline CandidatesResult(CandidatesResult&& from) noexcept
      : CandidatesResult(nullptr, ::std::move(from)) {}
  inline CandidatesResult& operator=(const CandidatesResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CandidatesResult& operator=(CandidatesResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CandidatesResult& default_instance() {
    return *reinterpret_cast<const CandidatesResult*>(
        &_CandidatesResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(CandidatesResult& a, CandidatesResult& b) { a.Swap(&b); }
  inline void Swap(CandidatesResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CandidatesResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CandidatesResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CandidatesResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CandidatesResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CandidatesResult& from) { CandidatesResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CandidatesResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "hazkey.commands.CandidatesResult"; }

 protected:
  explicit CandidatesResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CandidatesResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CandidatesResult& from);
  CandidatesResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CandidatesResult&& from) noexcept
      : CandidatesResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Candidate = CandidatesResult_Candidate;

  // accessors -------------------------------------------------------
  enum : int {
    kCandidatesFieldNumber = 1,
    kLiveTextFieldNumber = 2,
    kLiveTextIndexFieldNumber = 3,
    kPageSizeFieldNumber = 4,
  };
  // repeated .hazkey.commands.CandidatesResult.Candidate candidates = 1;
  int candidates_size() const;
  private:
  int _internal_candidates_size() const;

  public:
  void clear_candidates() ;
  ::hazkey::commands::CandidatesResult_Candidate* PROTOBUF_NONNULL mutable_candidates(int index);
  ::google::protobuf::RepeatedPtrField<::hazkey::commands::CandidatesResult_Candidate>* PROTOBUF_NONNULL mutable_candidates();

  private:
  const ::google::protobuf::RepeatedPtrField<::hazkey::commands::CandidatesResult_Candidate>& _internal_candidates() const;
  ::google::protobuf::RepeatedPtrField<::hazkey::commands::CandidatesResult_Candidate>* PROTOBUF_NONNULL _internal_mutable_candidates();
  public:
  const ::hazkey::commands::CandidatesResult_Candidate& candidates(int index) const;
  ::hazkey::commands::CandidatesResult_Candidate* PROTOBUF_NONNULL add_candidates();
  const ::google::protobuf::RepeatedPtrField<::hazkey::commands::CandidatesResult_Candidate>& candidates() const;
  // string live_text = 2;
  void clear_live_text() ;
  const ::std::string& live_text() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_live_text(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_live_text();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_live_text();
  void set_allocated_live_text(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_live_text() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_live_text(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_live_text();

  public:
  // int32 live_text_index = 3;
  void clear_live_text_index() ;
  ::int32_t live_text_index() const;
  void set_live_text_index(::int32_t value);

  private:
  ::int32_t _internal_live_text_index() const;
  void _internal_set_live_text_index(::int32_t value);

  public:
  // int32 page_size = 4;
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hazkey.commands.CandidatesResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 50,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CandidatesResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::hazkey::commands::CandidatesResult_Candidate > candidates_;
    ::google::protobuf::internal::ArenaStringPtr live_text_;
    ::int32_t live_text_index_;
    ::int32_t page_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CandidatesResult_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NewComposingText

// -------------------------------------------------------------------

// SetContext

// string context = 1;
inline void SetContext::clear_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.context_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SetContext::context() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.SetContext.context)
  return _internal_context();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SetContext::set_context(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.context_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.SetContext.context)
}
inline ::std::string* PROTOBUF_NONNULL SetContext::mutable_context()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.SetContext.context)
  return _s;
}
inline const ::std::string& SetContext::_internal_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.context_.Get();
}
inline void SetContext::_internal_set_context(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.context_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SetContext::_internal_mutable_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.context_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SetContext::release_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.SetContext.context)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.context_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.context_.Set("", GetArena());
  }
  return released;
}
inline void SetContext::set_allocated_context(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.context_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.context_.IsDefault()) {
    _impl_.context_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.SetContext.context)
}

// int32 anchor = 2;
inline void SetContext::clear_anchor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.anchor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SetContext::anchor() const {
  // @@protoc_insertion_point(field_get:hazkey.commands.SetContext.anchor)
  return _internal_anchor();
}
inline void SetContext::set_anchor(::int32_t value) {
  _internal_set_anchor(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:hazkey.commands.SetContext.anchor)
}
inline ::int32_t SetContext::_internal_anchor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.anchor_;
}
inline void SetContext::_internal_set_anchor(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.anchor_ = value;
}

// -------------------------------------------------------------------

// InputChar

// string text = 1;
inline void InputChar::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InputChar::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.InputChar.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InputChar::set_text(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.InputChar.text)
}
inline ::std::string* PROTOBUF_NONNULL InputChar::mutable_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.InputChar.text)
  return _s;
}
inline const ::std::string& InputChar::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void InputChar::_internal_set_text(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InputChar::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InputChar::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.InputChar.text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.text_.Set("", GetArena());
  }
  return released;
}
inline void InputChar::set_allocated_text(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.InputChar.text)
}

// bool is_direct = 2;
inline void InputChar::clear_is_direct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_direct_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool InputChar::is_direct() const {
  // @@protoc_insertion_point(field_get:hazkey.commands.InputChar.is_direct)
  return _internal_is_direct();
}
inline void InputChar::set_is_direct(bool value) {
  _internal_set_is_direct(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:hazkey.commands.InputChar.is_direct)
}
inline bool InputChar::_internal_is_direct() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_direct_;
}
inline void InputChar::_internal_set_is_direct(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_direct_ = value;
}

// -------------------------------------------------------------------

// MoveCursor

// int32 offset = 1;
inline void MoveCursor::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MoveCursor::offset() const {
  // @@protoc_insertion_point(field_get:hazkey.commands.MoveCursor.offset)
  return _internal_offset();
}
inline void MoveCursor::set_offset(::int32_t value) {
  _internal_set_offset(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:hazkey.commands.MoveCursor.offset)
}
inline ::int32_t MoveCursor::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void MoveCursor::_internal_set_offset(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// PrefixComplete

// int32 index = 1;
inline void PrefixComplete::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t PrefixComplete::index() const {
  // @@protoc_insertion_point(field_get:hazkey.commands.PrefixComplete.index)
  return _internal_index();
}
inline void PrefixComplete::set_index(::int32_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:hazkey.commands.PrefixComplete.index)
}
inline ::int32_t PrefixComplete::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void PrefixComplete::_internal_set_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// DeleteLeft

// -------------------------------------------------------------------

// DeleteRight

// -------------------------------------------------------------------

// GetComposingString

// .hazkey.commands.GetComposingString.CharType char_type = 1;
inline void GetComposingString::clear_char_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.char_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::hazkey::commands::GetComposingString_CharType GetComposingString::char_type() const {
  // @@protoc_insertion_point(field_get:hazkey.commands.GetComposingString.char_type)
  return _internal_char_type();
}
inline void GetComposingString::set_char_type(::hazkey::commands::GetComposingString_CharType value) {
  _internal_set_char_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:hazkey.commands.GetComposingString.char_type)
}
inline ::hazkey::commands::GetComposingString_CharType GetComposingString::_internal_char_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::hazkey::commands::GetComposingString_CharType>(_impl_.char_type_);
}
inline void GetComposingString::_internal_set_char_type(::hazkey::commands::GetComposingString_CharType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.char_type_ = value;
}

// string current_preedit = 2;
inline void GetComposingString::clear_current_preedit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_preedit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetComposingString::current_preedit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.GetComposingString.current_preedit)
  return _internal_current_preedit();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetComposingString::set_current_preedit(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.current_preedit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.GetComposingString.current_preedit)
}
inline ::std::string* PROTOBUF_NONNULL GetComposingString::mutable_current_preedit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_current_preedit();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.GetComposingString.current_preedit)
  return _s;
}
inline const ::std::string& GetComposingString::_internal_current_preedit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_preedit_.Get();
}
inline void GetComposingString::_internal_set_current_preedit(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.current_preedit_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetComposingString::_internal_mutable_current_preedit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.current_preedit_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetComposingString::release_current_preedit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.GetComposingString.current_preedit)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.current_preedit_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.current_preedit_.Set("", GetArena());
  }
  return released;
}
inline void GetComposingString::set_allocated_current_preedit(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.current_preedit_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.current_preedit_.IsDefault()) {
    _impl_.current_preedit_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.GetComposingString.current_preedit)
}

// -------------------------------------------------------------------

// GetHiraganaWithCursor

// -------------------------------------------------------------------

// GetCandidates

// bool is_suggest = 1;
inline void GetCandidates::clear_is_suggest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_suggest_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool GetCandidates::is_suggest() const {
  // @@protoc_insertion_point(field_get:hazkey.commands.GetCandidates.is_suggest)
  return _internal_is_suggest();
}
inline void GetCandidates::set_is_suggest(bool value) {
  _internal_set_is_suggest(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:hazkey.commands.GetCandidates.is_suggest)
}
inline bool GetCandidates::_internal_is_suggest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_suggest_;
}
inline void GetCandidates::_internal_set_is_suggest(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_suggest_ = value;
}

// -------------------------------------------------------------------

// Text

// string text = 1;
inline void Text::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Text::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.Text.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Text::set_text(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.Text.text)
}
inline ::std::string* PROTOBUF_NONNULL Text::mutable_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.Text.text)
  return _s;
}
inline const ::std::string& Text::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void Text::_internal_set_text(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Text::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Text::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.Text.text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.text_.Set("", GetArena());
  }
  return released;
}
inline void Text::set_allocated_text(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.Text.text)
}

// -------------------------------------------------------------------

// TextWithCursor

// string beforeCursosr = 1;
inline void TextWithCursor::clear_beforecursosr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beforecursosr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TextWithCursor::beforecursosr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.TextWithCursor.beforeCursosr)
  return _internal_beforecursosr();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TextWithCursor::set_beforecursosr(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.beforecursosr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.TextWithCursor.beforeCursosr)
}
inline ::std::string* PROTOBUF_NONNULL TextWithCursor::mutable_beforecursosr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_beforecursosr();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.TextWithCursor.beforeCursosr)
  return _s;
}
inline const ::std::string& TextWithCursor::_internal_beforecursosr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beforecursosr_.Get();
}
inline void TextWithCursor::_internal_set_beforecursosr(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.beforecursosr_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TextWithCursor::_internal_mutable_beforecursosr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.beforecursosr_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TextWithCursor::release_beforecursosr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.TextWithCursor.beforeCursosr)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.beforecursosr_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.beforecursosr_.Set("", GetArena());
  }
  return released;
}
inline void TextWithCursor::set_allocated_beforecursosr(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.beforecursosr_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.beforecursosr_.IsDefault()) {
    _impl_.beforecursosr_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.TextWithCursor.beforeCursosr)
}

// string onCursor = 2;
inline void TextWithCursor::clear_oncursor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.oncursor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TextWithCursor::oncursor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.TextWithCursor.onCursor)
  return _internal_oncursor();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TextWithCursor::set_oncursor(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.oncursor_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.TextWithCursor.onCursor)
}
inline ::std::string* PROTOBUF_NONNULL TextWithCursor::mutable_oncursor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_oncursor();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.TextWithCursor.onCursor)
  return _s;
}
inline const ::std::string& TextWithCursor::_internal_oncursor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.oncursor_.Get();
}
inline void TextWithCursor::_internal_set_oncursor(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.oncursor_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TextWithCursor::_internal_mutable_oncursor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.oncursor_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TextWithCursor::release_oncursor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.TextWithCursor.onCursor)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.oncursor_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.oncursor_.Set("", GetArena());
  }
  return released;
}
inline void TextWithCursor::set_allocated_oncursor(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.oncursor_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.oncursor_.IsDefault()) {
    _impl_.oncursor_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.TextWithCursor.onCursor)
}

// string afterCursor = 3;
inline void TextWithCursor::clear_aftercursor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aftercursor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& TextWithCursor::aftercursor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.TextWithCursor.afterCursor)
  return _internal_aftercursor();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TextWithCursor::set_aftercursor(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.aftercursor_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.TextWithCursor.afterCursor)
}
inline ::std::string* PROTOBUF_NONNULL TextWithCursor::mutable_aftercursor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_aftercursor();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.TextWithCursor.afterCursor)
  return _s;
}
inline const ::std::string& TextWithCursor::_internal_aftercursor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aftercursor_.Get();
}
inline void TextWithCursor::_internal_set_aftercursor(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.aftercursor_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TextWithCursor::_internal_mutable_aftercursor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.aftercursor_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TextWithCursor::release_aftercursor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.TextWithCursor.afterCursor)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.aftercursor_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.aftercursor_.Set("", GetArena());
  }
  return released;
}
inline void TextWithCursor::set_allocated_aftercursor(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.aftercursor_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.aftercursor_.IsDefault()) {
    _impl_.aftercursor_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.TextWithCursor.afterCursor)
}

// -------------------------------------------------------------------

// CandidatesResult_Candidate

// string text = 1;
inline void CandidatesResult_Candidate::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CandidatesResult_Candidate::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.CandidatesResult.Candidate.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CandidatesResult_Candidate::set_text(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.CandidatesResult.Candidate.text)
}
inline ::std::string* PROTOBUF_NONNULL CandidatesResult_Candidate::mutable_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.CandidatesResult.Candidate.text)
  return _s;
}
inline const ::std::string& CandidatesResult_Candidate::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void CandidatesResult_Candidate::_internal_set_text(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CandidatesResult_Candidate::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CandidatesResult_Candidate::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.CandidatesResult.Candidate.text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.text_.Set("", GetArena());
  }
  return released;
}
inline void CandidatesResult_Candidate::set_allocated_text(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.CandidatesResult.Candidate.text)
}

// string sub_hiragana = 2;
inline void CandidatesResult_Candidate::clear_sub_hiragana() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_hiragana_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CandidatesResult_Candidate::sub_hiragana() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.CandidatesResult.Candidate.sub_hiragana)
  return _internal_sub_hiragana();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CandidatesResult_Candidate::set_sub_hiragana(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sub_hiragana_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.CandidatesResult.Candidate.sub_hiragana)
}
inline ::std::string* PROTOBUF_NONNULL CandidatesResult_Candidate::mutable_sub_hiragana()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_sub_hiragana();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.CandidatesResult.Candidate.sub_hiragana)
  return _s;
}
inline const ::std::string& CandidatesResult_Candidate::_internal_sub_hiragana() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sub_hiragana_.Get();
}
inline void CandidatesResult_Candidate::_internal_set_sub_hiragana(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sub_hiragana_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CandidatesResult_Candidate::_internal_mutable_sub_hiragana() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sub_hiragana_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CandidatesResult_Candidate::release_sub_hiragana() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.CandidatesResult.Candidate.sub_hiragana)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.sub_hiragana_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sub_hiragana_.Set("", GetArena());
  }
  return released;
}
inline void CandidatesResult_Candidate::set_allocated_sub_hiragana(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sub_hiragana_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sub_hiragana_.IsDefault()) {
    _impl_.sub_hiragana_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.CandidatesResult.Candidate.sub_hiragana)
}

// repeated string words = 3;
inline int CandidatesResult_Candidate::_internal_words_size() const {
  return _internal_words().size();
}
inline int CandidatesResult_Candidate::words_size() const {
  return _internal_words_size();
}
inline void CandidatesResult_Candidate::clear_words() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.words_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL CandidatesResult_Candidate::add_words()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_words()->Add();
  // @@protoc_insertion_point(field_add_mutable:hazkey.commands.CandidatesResult.Candidate.words)
  return _s;
}
inline const ::std::string& CandidatesResult_Candidate::words(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.CandidatesResult.Candidate.words)
  return _internal_words().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL CandidatesResult_Candidate::mutable_words(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hazkey.commands.CandidatesResult.Candidate.words)
  return _internal_mutable_words()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CandidatesResult_Candidate::set_words(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_words()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:hazkey.commands.CandidatesResult.Candidate.words)
}
template <typename Arg_, typename... Args_>
inline void CandidatesResult_Candidate::add_words(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_words(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:hazkey.commands.CandidatesResult.Candidate.words)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& CandidatesResult_Candidate::words()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hazkey.commands.CandidatesResult.Candidate.words)
  return _internal_words();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CandidatesResult_Candidate::mutable_words() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hazkey.commands.CandidatesResult.Candidate.words)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_words();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CandidatesResult_Candidate::_internal_words() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.words_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CandidatesResult_Candidate::_internal_mutable_words() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.words_;
}

// repeated int32 diff_indexes = 4;
inline int CandidatesResult_Candidate::_internal_diff_indexes_size() const {
  return _internal_diff_indexes().size();
}
inline int CandidatesResult_Candidate::diff_indexes_size() const {
  return _internal_diff_indexes_size();
}
inline void CandidatesResult_Candidate::clear_diff_indexes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.diff_indexes_.Clear();
}
inline ::int32_t CandidatesResult_Candidate::diff_indexes(int index) const {
  // @@protoc_insertion_point(field_get:hazkey.commands.CandidatesResult.Candidate.diff_indexes)
  return _internal_diff_indexes().Get(index);
}
inline void CandidatesResult_Candidate::set_diff_indexes(int index, ::int32_t value) {
  _internal_mutable_diff_indexes()->Set(index, value);
  // @@protoc_insertion_point(field_set:hazkey.commands.CandidatesResult.Candidate.diff_indexes)
}
inline void CandidatesResult_Candidate::add_diff_indexes(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_diff_indexes()->Add(value);
  // @@protoc_insertion_point(field_add:hazkey.commands.CandidatesResult.Candidate.diff_indexes)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CandidatesResult_Candidate::diff_indexes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hazkey.commands.CandidatesResult.Candidate.diff_indexes)
  return _internal_diff_indexes();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL CandidatesResult_Candidate::mutable_diff_indexes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hazkey.commands.CandidatesResult.Candidate.diff_indexes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_diff_indexes();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
CandidatesResult_Candidate::_internal_diff_indexes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.diff_indexes_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
CandidatesResult_Candidate::_internal_mutable_diff_indexes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.diff_indexes_;
}

// -------------------------------------------------------------------

// CandidatesResult

// repeated .hazkey.commands.CandidatesResult.Candidate candidates = 1;
inline int CandidatesResult::_internal_candidates_size() const {
  return _internal_candidates().size();
}
inline int CandidatesResult::candidates_size() const {
  return _internal_candidates_size();
}
inline void CandidatesResult::clear_candidates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.candidates_.Clear();
}
inline ::hazkey::commands::CandidatesResult_Candidate* PROTOBUF_NONNULL CandidatesResult::mutable_candidates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hazkey.commands.CandidatesResult.candidates)
  return _internal_mutable_candidates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hazkey::commands::CandidatesResult_Candidate>* PROTOBUF_NONNULL CandidatesResult::mutable_candidates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hazkey.commands.CandidatesResult.candidates)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_candidates();
}
inline const ::hazkey::commands::CandidatesResult_Candidate& CandidatesResult::candidates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.CandidatesResult.candidates)
  return _internal_candidates().Get(index);
}
inline ::hazkey::commands::CandidatesResult_Candidate* PROTOBUF_NONNULL CandidatesResult::add_candidates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::hazkey::commands::CandidatesResult_Candidate* _add = _internal_mutable_candidates()->Add();
  // @@protoc_insertion_point(field_add:hazkey.commands.CandidatesResult.candidates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hazkey::commands::CandidatesResult_Candidate>& CandidatesResult::candidates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hazkey.commands.CandidatesResult.candidates)
  return _internal_candidates();
}
inline const ::google::protobuf::RepeatedPtrField<::hazkey::commands::CandidatesResult_Candidate>&
CandidatesResult::_internal_candidates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.candidates_;
}
inline ::google::protobuf::RepeatedPtrField<::hazkey::commands::CandidatesResult_Candidate>* PROTOBUF_NONNULL
CandidatesResult::_internal_mutable_candidates() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.candidates_;
}

// string live_text = 2;
inline void CandidatesResult::clear_live_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.live_text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CandidatesResult::live_text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hazkey.commands.CandidatesResult.live_text)
  return _internal_live_text();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CandidatesResult::set_live_text(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.live_text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hazkey.commands.CandidatesResult.live_text)
}
inline ::std::string* PROTOBUF_NONNULL CandidatesResult::mutable_live_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_live_text();
  // @@protoc_insertion_point(field_mutable:hazkey.commands.CandidatesResult.live_text)
  return _s;
}
inline const ::std::string& CandidatesResult::_internal_live_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.live_text_.Get();
}
inline void CandidatesResult::_internal_set_live_text(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.live_text_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CandidatesResult::_internal_mutable_live_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.live_text_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CandidatesResult::release_live_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hazkey.commands.CandidatesResult.live_text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.live_text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.live_text_.Set("", GetArena());
  }
  return released;
}
inline void CandidatesResult::set_allocated_live_text(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.live_text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.live_text_.IsDefault()) {
    _impl_.live_text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:hazkey.commands.CandidatesResult.live_text)
}

// int32 live_text_index = 3;
inline void CandidatesResult::clear_live_text_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.live_text_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CandidatesResult::live_text_index() const {
  // @@protoc_insertion_point(field_get:hazkey.commands.CandidatesResult.live_text_index)
  return _internal_live_text_index();
}
inline void CandidatesResult::set_live_text_index(::int32_t value) {
  _internal_set_live_text_index(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:hazkey.commands.CandidatesResult.live_text_index)
}
inline ::int32_t CandidatesResult::_internal_live_text_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.live_text_index_;
}
inline void CandidatesResult::_internal_set_live_text_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.live_text_index_ = value;
}

// int32 page_size = 4;
inline void CandidatesResult::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CandidatesResult::page_size() const {
  // @@protoc_insertion_point(field_get:hazkey.commands.CandidatesResult.page_size)
  return _internal_page_size();
}
inline void CandidatesResult::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:hazkey.commands.CandidatesResult.page_size)
}
inline ::int32_t CandidatesResult::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void CandidatesResult::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace commands
}  // namespace hazkey


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::hazkey::commands::GetComposingString_CharType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::hazkey::commands::GetComposingString_CharType>() {
  return ::hazkey::commands::GetComposingString_CharType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // commands_2eproto_2epb_2eh
